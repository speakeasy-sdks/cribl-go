// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

type Output402ExtraHTTPHeaders struct {
	// Field name
	Name *string `json:"name,omitempty"`
	// Field value
	Value string `json:"value"`
}

func (o *Output402ExtraHTTPHeaders) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Output402ExtraHTTPHeaders) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// Output402FailedRequestLoggingMode - Determines which data should be logged when a request fails. Defaults to None.  All headers are redacted by default, except those listed under `Safe Headers`.
type Output402FailedRequestLoggingMode string

const (
	Output402FailedRequestLoggingModePayload           Output402FailedRequestLoggingMode = "payload"
	Output402FailedRequestLoggingModePayloadAndHeaders Output402FailedRequestLoggingMode = "payloadAndHeaders"
	Output402FailedRequestLoggingModeNone              Output402FailedRequestLoggingMode = "none"
)

func (e Output402FailedRequestLoggingMode) ToPointer() *Output402FailedRequestLoggingMode {
	return &e
}

func (e *Output402FailedRequestLoggingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "payload":
		fallthrough
	case "payloadAndHeaders":
		fallthrough
	case "none":
		*e = Output402FailedRequestLoggingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output402FailedRequestLoggingMode: %v", v)
	}
}

type Output402Labels struct {
	// Name of the label.
	Name string `json:"name"`
	// Value of the label.
	Value string `json:"value"`
}

func (o *Output402Labels) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Output402Labels) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// Output402LokiAuthAuthenticationType - The authentication method to use for the HTTP requests
type Output402LokiAuthAuthenticationType string

const (
	Output402LokiAuthAuthenticationTypeCredentialsSecret Output402LokiAuthAuthenticationType = "credentialsSecret"
	Output402LokiAuthAuthenticationTypeToken             Output402LokiAuthAuthenticationType = "token"
	Output402LokiAuthAuthenticationTypeTextSecret        Output402LokiAuthAuthenticationType = "textSecret"
	Output402LokiAuthAuthenticationTypeBasic             Output402LokiAuthAuthenticationType = "basic"
)

func (e Output402LokiAuthAuthenticationType) ToPointer() *Output402LokiAuthAuthenticationType {
	return &e
}

func (e *Output402LokiAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		fallthrough
	case "basic":
		*e = Output402LokiAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output402LokiAuthAuthenticationType: %v", v)
	}
}

type Output402LokiAuth struct {
	// The authentication method to use for the HTTP requests
	AuthType *Output402LokiAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Password (a.k.a API key in Grafana Cloud domain) for authentication
	Password *string `json:"password,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>.
	Token *string `json:"token,omitempty"`
	// Username for authentication
	Username *string `json:"username,omitempty"`
}

func (o *Output402LokiAuth) GetAuthType() *Output402LokiAuthAuthenticationType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Output402LokiAuth) GetCredentialsSecret() *string {
	if o == nil {
		return nil
	}
	return o.CredentialsSecret
}

func (o *Output402LokiAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *Output402LokiAuth) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

func (o *Output402LokiAuth) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

func (o *Output402LokiAuth) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

// Output402MessageFormat - Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
type Output402MessageFormat string

const (
	Output402MessageFormatProtobuf Output402MessageFormat = "protobuf"
	Output402MessageFormatJSON     Output402MessageFormat = "json"
)

func (e Output402MessageFormat) ToPointer() *Output402MessageFormat {
	return &e
}

func (e *Output402MessageFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "protobuf":
		fallthrough
	case "json":
		*e = Output402MessageFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output402MessageFormat: %v", v)
	}
}

// Output402BackpressureBehavior - Whether to block, drop, or queue events when all receivers are exerting backpressure.
type Output402BackpressureBehavior string

const (
	Output402BackpressureBehaviorQueue Output402BackpressureBehavior = "queue"
	Output402BackpressureBehaviorDrop  Output402BackpressureBehavior = "drop"
	Output402BackpressureBehaviorBlock Output402BackpressureBehavior = "block"
)

func (e Output402BackpressureBehavior) ToPointer() *Output402BackpressureBehavior {
	return &e
}

func (e *Output402BackpressureBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "queue":
		fallthrough
	case "drop":
		fallthrough
	case "block":
		*e = Output402BackpressureBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output402BackpressureBehavior: %v", v)
	}
}

// Output402Compression - Codec to use to compress the persisted data.
type Output402Compression string

const (
	Output402CompressionNone Output402Compression = "none"
	Output402CompressionGzip Output402Compression = "gzip"
)

func (e Output402Compression) ToPointer() *Output402Compression {
	return &e
}

func (e *Output402Compression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = Output402Compression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output402Compression: %v", v)
	}
}

type Output402PqControls struct {
}

// Output402QueueFullBehavior - Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type Output402QueueFullBehavior string

const (
	Output402QueueFullBehaviorBlock Output402QueueFullBehavior = "block"
	Output402QueueFullBehaviorDrop  Output402QueueFullBehavior = "drop"
)

func (e Output402QueueFullBehavior) ToPointer() *Output402QueueFullBehavior {
	return &e
}

func (e *Output402QueueFullBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "drop":
		*e = Output402QueueFullBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output402QueueFullBehavior: %v", v)
	}
}

// Output402PrometheusAuthAuthenticationType - The authentication method to use for the HTTP requests
type Output402PrometheusAuthAuthenticationType string

const (
	Output402PrometheusAuthAuthenticationTypeCredentialsSecret Output402PrometheusAuthAuthenticationType = "credentialsSecret"
	Output402PrometheusAuthAuthenticationTypeToken             Output402PrometheusAuthAuthenticationType = "token"
	Output402PrometheusAuthAuthenticationTypeTextSecret        Output402PrometheusAuthAuthenticationType = "textSecret"
	Output402PrometheusAuthAuthenticationTypeBasic             Output402PrometheusAuthAuthenticationType = "basic"
)

func (e Output402PrometheusAuthAuthenticationType) ToPointer() *Output402PrometheusAuthAuthenticationType {
	return &e
}

func (e *Output402PrometheusAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		fallthrough
	case "basic":
		*e = Output402PrometheusAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output402PrometheusAuthAuthenticationType: %v", v)
	}
}

type Output402PrometheusAuth struct {
	// The authentication method to use for the HTTP requests
	AuthType *Output402PrometheusAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Password (a.k.a API key in Grafana Cloud domain) for authentication
	Password *string `json:"password,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>.
	Token *string `json:"token,omitempty"`
	// Username for authentication
	Username *string `json:"username,omitempty"`
}

func (o *Output402PrometheusAuth) GetAuthType() *Output402PrometheusAuthAuthenticationType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Output402PrometheusAuth) GetCredentialsSecret() *string {
	if o == nil {
		return nil
	}
	return o.CredentialsSecret
}

func (o *Output402PrometheusAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *Output402PrometheusAuth) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

func (o *Output402PrometheusAuth) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

func (o *Output402PrometheusAuth) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

type Output402Type string

const (
	Output402TypeGrafanaCloud Output402Type = "grafana_cloud"
)

func (e Output402Type) ToPointer() *Output402Type {
	return &e
}

func (e *Output402Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana_cloud":
		*e = Output402Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output402Type: %v", v)
	}
}

type Output402 struct {
	// Whether to compress the payload body before sending. Applies only to Loki's JSON payloads, as both Prometheus' and Loki's Protobuf variant are snappy-compressed by default.
	Compress *bool `json:"compress,omitempty"`
	// Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order.
	Concurrency *int64 `json:"concurrency,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Headers to add to all events.
	ExtraHTTPHeaders []Output402ExtraHTTPHeaders `json:"extraHttpHeaders,omitempty"`
	// Determines which data should be logged when a request fails. Defaults to None.  All headers are redacted by default, except those listed under `Safe Headers`.
	FailedRequestLoggingMode *Output402FailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`
	// Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	FlushPeriodSec *int64 `json:"flushPeriodSec,omitempty"`
	// Unique ID for this output
	ID *string `json:"id,omitempty"`
	// List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field (e.g.: '__labels: {host: "cribl.io", level: "error"}').
	Labels   []Output402Labels  `json:"labels,omitempty"`
	LokiAuth *Output402LokiAuth `json:"lokiAuth,omitempty"`
	// The endpoint to send logs to, e.g.: https://logs-prod-us-central1.grafana.net
	LokiURL string `json:"lokiUrl"`
	// Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	MaxPayloadEvents *int64 `json:"maxPayloadEvents,omitempty"`
	// Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	MaxPayloadSizeKB *int64 `json:"maxPayloadSizeKB,omitempty"`
	// Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
	Message *string `json:"message,omitempty"`
	// Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
	MessageFormat *Output402MessageFormat `json:"messageFormat,omitempty"`
	// A JS expression that can be used to rename metrics. E.g.: name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name.  You can access event fields' values via __e.<fieldName>.
	MetricRenameExpr *string `json:"metricRenameExpr,omitempty"`
	// Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *Output402BackpressureBehavior `json:"onBackpressure,omitempty"`
	// Pipeline to process data before sending out to this output.
	Pipeline *string `json:"pipeline,omitempty"`
	// Codec to use to compress the persisted data.
	PqCompress *Output402Compression `json:"pqCompress,omitempty"`
	PqControls *Output402PqControls  `json:"pqControls,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`
	// Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *Output402QueueFullBehavior `json:"pqOnBackpressure,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`
	// Toggle this off to forward new events to receiver(s) before queue is flushed. Otherwise, default drain behavior is FIFO (first in, first out).
	PqStrictOrdering *bool                    `json:"pqStrictOrdering,omitempty"`
	PrometheusAuth   *Output402PrometheusAuth `json:"prometheusAuth,omitempty"`
	// The remote_write endpoint to send Prometheus metrics to, e.g.: https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push
	PrometheusURL string `json:"prometheusUrl"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Defaults to Yes.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// List of headers that are safe to log in plain text.
	SafeHeaders []string `json:"safeHeaders,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Set of fields to automatically add to events using this output. E.g.: cribl_pipe, c*. Wildcards supported. These fields are added as dimensions and labels to generated metrics and logs respectively.
	SystemFields []string `json:"systemFields,omitempty"`
	// Amount of time, in seconds, to wait for a request to complete before aborting it.
	TimeoutSec *int64         `json:"timeoutSec,omitempty"`
	Type       *Output402Type `json:"type,omitempty"`
	// Enable to use round-robin DNS lookup. When a DNS server returns multiple addresses, this will cause Stream to cycle through them in the order returned.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitempty"`
}

func (o *Output402) GetCompress() *bool {
	if o == nil {
		return nil
	}
	return o.Compress
}

func (o *Output402) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *Output402) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *Output402) GetExtraHTTPHeaders() []Output402ExtraHTTPHeaders {
	if o == nil {
		return nil
	}
	return o.ExtraHTTPHeaders
}

func (o *Output402) GetFailedRequestLoggingMode() *Output402FailedRequestLoggingMode {
	if o == nil {
		return nil
	}
	return o.FailedRequestLoggingMode
}

func (o *Output402) GetFlushPeriodSec() *int64 {
	if o == nil {
		return nil
	}
	return o.FlushPeriodSec
}

func (o *Output402) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Output402) GetLabels() []Output402Labels {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *Output402) GetLokiAuth() *Output402LokiAuth {
	if o == nil {
		return nil
	}
	return o.LokiAuth
}

func (o *Output402) GetLokiURL() string {
	if o == nil {
		return ""
	}
	return o.LokiURL
}

func (o *Output402) GetMaxPayloadEvents() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPayloadEvents
}

func (o *Output402) GetMaxPayloadSizeKB() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPayloadSizeKB
}

func (o *Output402) GetMessage() *string {
	if o == nil {
		return nil
	}
	return o.Message
}

func (o *Output402) GetMessageFormat() *Output402MessageFormat {
	if o == nil {
		return nil
	}
	return o.MessageFormat
}

func (o *Output402) GetMetricRenameExpr() *string {
	if o == nil {
		return nil
	}
	return o.MetricRenameExpr
}

func (o *Output402) GetOnBackpressure() *Output402BackpressureBehavior {
	if o == nil {
		return nil
	}
	return o.OnBackpressure
}

func (o *Output402) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *Output402) GetPqCompress() *Output402Compression {
	if o == nil {
		return nil
	}
	return o.PqCompress
}

func (o *Output402) GetPqControls() *Output402PqControls {
	if o == nil {
		return nil
	}
	return o.PqControls
}

func (o *Output402) GetPqMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxFileSize
}

func (o *Output402) GetPqMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxSize
}

func (o *Output402) GetPqOnBackpressure() *Output402QueueFullBehavior {
	if o == nil {
		return nil
	}
	return o.PqOnBackpressure
}

func (o *Output402) GetPqPath() *string {
	if o == nil {
		return nil
	}
	return o.PqPath
}

func (o *Output402) GetPqStrictOrdering() *bool {
	if o == nil {
		return nil
	}
	return o.PqStrictOrdering
}

func (o *Output402) GetPrometheusAuth() *Output402PrometheusAuth {
	if o == nil {
		return nil
	}
	return o.PrometheusAuth
}

func (o *Output402) GetPrometheusURL() string {
	if o == nil {
		return ""
	}
	return o.PrometheusURL
}

func (o *Output402) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *Output402) GetSafeHeaders() []string {
	if o == nil {
		return nil
	}
	return o.SafeHeaders
}

func (o *Output402) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *Output402) GetSystemFields() []string {
	if o == nil {
		return nil
	}
	return o.SystemFields
}

func (o *Output402) GetTimeoutSec() *int64 {
	if o == nil {
		return nil
	}
	return o.TimeoutSec
}

func (o *Output402) GetType() *Output402Type {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Output402) GetUseRoundRobinDNS() *bool {
	if o == nil {
		return nil
	}
	return o.UseRoundRobinDNS
}

type Output401ExtraHTTPHeaders struct {
	// Field name
	Name *string `json:"name,omitempty"`
	// Field value
	Value string `json:"value"`
}

func (o *Output401ExtraHTTPHeaders) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Output401ExtraHTTPHeaders) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// Output401FailedRequestLoggingMode - Determines which data should be logged when a request fails. Defaults to None.  All headers are redacted by default, except those listed under `Safe Headers`.
type Output401FailedRequestLoggingMode string

const (
	Output401FailedRequestLoggingModePayload           Output401FailedRequestLoggingMode = "payload"
	Output401FailedRequestLoggingModePayloadAndHeaders Output401FailedRequestLoggingMode = "payloadAndHeaders"
	Output401FailedRequestLoggingModeNone              Output401FailedRequestLoggingMode = "none"
)

func (e Output401FailedRequestLoggingMode) ToPointer() *Output401FailedRequestLoggingMode {
	return &e
}

func (e *Output401FailedRequestLoggingMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "payload":
		fallthrough
	case "payloadAndHeaders":
		fallthrough
	case "none":
		*e = Output401FailedRequestLoggingMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output401FailedRequestLoggingMode: %v", v)
	}
}

type Output401Labels struct {
	// Name of the label.
	Name string `json:"name"`
	// Value of the label.
	Value string `json:"value"`
}

func (o *Output401Labels) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Output401Labels) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// Output401LokiAuthAuthenticationType - The authentication method to use for the HTTP requests
type Output401LokiAuthAuthenticationType string

const (
	Output401LokiAuthAuthenticationTypeCredentialsSecret Output401LokiAuthAuthenticationType = "credentialsSecret"
	Output401LokiAuthAuthenticationTypeToken             Output401LokiAuthAuthenticationType = "token"
	Output401LokiAuthAuthenticationTypeTextSecret        Output401LokiAuthAuthenticationType = "textSecret"
	Output401LokiAuthAuthenticationTypeBasic             Output401LokiAuthAuthenticationType = "basic"
)

func (e Output401LokiAuthAuthenticationType) ToPointer() *Output401LokiAuthAuthenticationType {
	return &e
}

func (e *Output401LokiAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		fallthrough
	case "basic":
		*e = Output401LokiAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output401LokiAuthAuthenticationType: %v", v)
	}
}

type Output401LokiAuth struct {
	// The authentication method to use for the HTTP requests
	AuthType *Output401LokiAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Password (a.k.a API key in Grafana Cloud domain) for authentication
	Password *string `json:"password,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>.
	Token *string `json:"token,omitempty"`
	// Username for authentication
	Username *string `json:"username,omitempty"`
}

func (o *Output401LokiAuth) GetAuthType() *Output401LokiAuthAuthenticationType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Output401LokiAuth) GetCredentialsSecret() *string {
	if o == nil {
		return nil
	}
	return o.CredentialsSecret
}

func (o *Output401LokiAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *Output401LokiAuth) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

func (o *Output401LokiAuth) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

func (o *Output401LokiAuth) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

// Output401MessageFormat - Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
type Output401MessageFormat string

const (
	Output401MessageFormatProtobuf Output401MessageFormat = "protobuf"
	Output401MessageFormatJSON     Output401MessageFormat = "json"
)

func (e Output401MessageFormat) ToPointer() *Output401MessageFormat {
	return &e
}

func (e *Output401MessageFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "protobuf":
		fallthrough
	case "json":
		*e = Output401MessageFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output401MessageFormat: %v", v)
	}
}

// Output401BackpressureBehavior - Whether to block, drop, or queue events when all receivers are exerting backpressure.
type Output401BackpressureBehavior string

const (
	Output401BackpressureBehaviorQueue Output401BackpressureBehavior = "queue"
	Output401BackpressureBehaviorDrop  Output401BackpressureBehavior = "drop"
	Output401BackpressureBehaviorBlock Output401BackpressureBehavior = "block"
)

func (e Output401BackpressureBehavior) ToPointer() *Output401BackpressureBehavior {
	return &e
}

func (e *Output401BackpressureBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "queue":
		fallthrough
	case "drop":
		fallthrough
	case "block":
		*e = Output401BackpressureBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output401BackpressureBehavior: %v", v)
	}
}

// Output401Compression - Codec to use to compress the persisted data.
type Output401Compression string

const (
	Output401CompressionNone Output401Compression = "none"
	Output401CompressionGzip Output401Compression = "gzip"
)

func (e Output401Compression) ToPointer() *Output401Compression {
	return &e
}

func (e *Output401Compression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = Output401Compression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output401Compression: %v", v)
	}
}

type Output401PqControls struct {
}

// Output401QueueFullBehavior - Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type Output401QueueFullBehavior string

const (
	Output401QueueFullBehaviorBlock Output401QueueFullBehavior = "block"
	Output401QueueFullBehaviorDrop  Output401QueueFullBehavior = "drop"
)

func (e Output401QueueFullBehavior) ToPointer() *Output401QueueFullBehavior {
	return &e
}

func (e *Output401QueueFullBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "drop":
		*e = Output401QueueFullBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output401QueueFullBehavior: %v", v)
	}
}

// Output401PrometheusAuthAuthenticationType - The authentication method to use for the HTTP requests
type Output401PrometheusAuthAuthenticationType string

const (
	Output401PrometheusAuthAuthenticationTypeCredentialsSecret Output401PrometheusAuthAuthenticationType = "credentialsSecret"
	Output401PrometheusAuthAuthenticationTypeToken             Output401PrometheusAuthAuthenticationType = "token"
	Output401PrometheusAuthAuthenticationTypeTextSecret        Output401PrometheusAuthAuthenticationType = "textSecret"
	Output401PrometheusAuthAuthenticationTypeBasic             Output401PrometheusAuthAuthenticationType = "basic"
)

func (e Output401PrometheusAuthAuthenticationType) ToPointer() *Output401PrometheusAuthAuthenticationType {
	return &e
}

func (e *Output401PrometheusAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		fallthrough
	case "basic":
		*e = Output401PrometheusAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output401PrometheusAuthAuthenticationType: %v", v)
	}
}

type Output401PrometheusAuth struct {
	// The authentication method to use for the HTTP requests
	AuthType *Output401PrometheusAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// Password (a.k.a API key in Grafana Cloud domain) for authentication
	Password *string `json:"password,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. E.g.: <your-username>:<your-api-key>.
	Token *string `json:"token,omitempty"`
	// Username for authentication
	Username *string `json:"username,omitempty"`
}

func (o *Output401PrometheusAuth) GetAuthType() *Output401PrometheusAuthAuthenticationType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Output401PrometheusAuth) GetCredentialsSecret() *string {
	if o == nil {
		return nil
	}
	return o.CredentialsSecret
}

func (o *Output401PrometheusAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *Output401PrometheusAuth) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

func (o *Output401PrometheusAuth) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

func (o *Output401PrometheusAuth) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

type Output401Type string

const (
	Output401TypeGrafanaCloud Output401Type = "grafana_cloud"
)

func (e Output401Type) ToPointer() *Output401Type {
	return &e
}

func (e *Output401Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana_cloud":
		*e = Output401Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Output401Type: %v", v)
	}
}

type Output401 struct {
	// Whether to compress the payload body before sending. Applies only to Loki's JSON payloads, as both Prometheus' and Loki's Protobuf variant are snappy-compressed by default.
	Compress *bool `json:"compress,omitempty"`
	// Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order.
	Concurrency *int64 `json:"concurrency,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Headers to add to all events.
	ExtraHTTPHeaders []Output401ExtraHTTPHeaders `json:"extraHttpHeaders,omitempty"`
	// Determines which data should be logged when a request fails. Defaults to None.  All headers are redacted by default, except those listed under `Safe Headers`.
	FailedRequestLoggingMode *Output401FailedRequestLoggingMode `json:"failedRequestLoggingMode,omitempty"`
	// Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	FlushPeriodSec *int64 `json:"flushPeriodSec,omitempty"`
	// Unique ID for this output
	ID *string `json:"id,omitempty"`
	// List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the event's __labels field (e.g.: '__labels: {host: "cribl.io", level: "error"}').
	Labels   []Output401Labels  `json:"labels,omitempty"`
	LokiAuth *Output401LokiAuth `json:"lokiAuth,omitempty"`
	// The endpoint to send logs to, e.g.: https://logs-prod-us-central1.grafana.net
	LokiURL string `json:"lokiUrl"`
	// Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	MaxPayloadEvents *int64 `json:"maxPayloadEvents,omitempty"`
	// Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order.
	MaxPayloadSizeKB *int64 `json:"maxPayloadSizeKB,omitempty"`
	// Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
	Message *string `json:"message,omitempty"`
	// Which format to use when sending logs to Loki (Protobuf or JSON).  Defaults to Protobuf.
	MessageFormat *Output401MessageFormat `json:"messageFormat,omitempty"`
	// A JS expression that can be used to rename metrics. E.g.: name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name.  You can access event fields' values via __e.<fieldName>.
	MetricRenameExpr *string `json:"metricRenameExpr,omitempty"`
	// Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *Output401BackpressureBehavior `json:"onBackpressure,omitempty"`
	// Pipeline to process data before sending out to this output.
	Pipeline *string `json:"pipeline,omitempty"`
	// Codec to use to compress the persisted data.
	PqCompress *Output401Compression `json:"pqCompress,omitempty"`
	PqControls *Output401PqControls  `json:"pqControls,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`
	// Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *Output401QueueFullBehavior `json:"pqOnBackpressure,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`
	// Toggle this off to forward new events to receiver(s) before queue is flushed. Otherwise, default drain behavior is FIFO (first in, first out).
	PqStrictOrdering *bool                    `json:"pqStrictOrdering,omitempty"`
	PrometheusAuth   *Output401PrometheusAuth `json:"prometheusAuth,omitempty"`
	// The remote_write endpoint to send Prometheus metrics to, e.g.: https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push
	PrometheusURL string `json:"prometheusUrl"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Defaults to Yes.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// List of headers that are safe to log in plain text.
	SafeHeaders []string `json:"safeHeaders,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Set of fields to automatically add to events using this output. E.g.: cribl_pipe, c*. Wildcards supported. These fields are added as dimensions and labels to generated metrics and logs respectively.
	SystemFields []string `json:"systemFields,omitempty"`
	// Amount of time, in seconds, to wait for a request to complete before aborting it.
	TimeoutSec *int64         `json:"timeoutSec,omitempty"`
	Type       *Output401Type `json:"type,omitempty"`
	// Enable to use round-robin DNS lookup. When a DNS server returns multiple addresses, this will cause Stream to cycle through them in the order returned.
	UseRoundRobinDNS *bool `json:"useRoundRobinDns,omitempty"`
}

func (o *Output401) GetCompress() *bool {
	if o == nil {
		return nil
	}
	return o.Compress
}

func (o *Output401) GetConcurrency() *int64 {
	if o == nil {
		return nil
	}
	return o.Concurrency
}

func (o *Output401) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *Output401) GetExtraHTTPHeaders() []Output401ExtraHTTPHeaders {
	if o == nil {
		return nil
	}
	return o.ExtraHTTPHeaders
}

func (o *Output401) GetFailedRequestLoggingMode() *Output401FailedRequestLoggingMode {
	if o == nil {
		return nil
	}
	return o.FailedRequestLoggingMode
}

func (o *Output401) GetFlushPeriodSec() *int64 {
	if o == nil {
		return nil
	}
	return o.FlushPeriodSec
}

func (o *Output401) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Output401) GetLabels() []Output401Labels {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *Output401) GetLokiAuth() *Output401LokiAuth {
	if o == nil {
		return nil
	}
	return o.LokiAuth
}

func (o *Output401) GetLokiURL() string {
	if o == nil {
		return ""
	}
	return o.LokiURL
}

func (o *Output401) GetMaxPayloadEvents() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPayloadEvents
}

func (o *Output401) GetMaxPayloadSizeKB() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxPayloadSizeKB
}

func (o *Output401) GetMessage() *string {
	if o == nil {
		return nil
	}
	return o.Message
}

func (o *Output401) GetMessageFormat() *Output401MessageFormat {
	if o == nil {
		return nil
	}
	return o.MessageFormat
}

func (o *Output401) GetMetricRenameExpr() *string {
	if o == nil {
		return nil
	}
	return o.MetricRenameExpr
}

func (o *Output401) GetOnBackpressure() *Output401BackpressureBehavior {
	if o == nil {
		return nil
	}
	return o.OnBackpressure
}

func (o *Output401) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *Output401) GetPqCompress() *Output401Compression {
	if o == nil {
		return nil
	}
	return o.PqCompress
}

func (o *Output401) GetPqControls() *Output401PqControls {
	if o == nil {
		return nil
	}
	return o.PqControls
}

func (o *Output401) GetPqMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxFileSize
}

func (o *Output401) GetPqMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxSize
}

func (o *Output401) GetPqOnBackpressure() *Output401QueueFullBehavior {
	if o == nil {
		return nil
	}
	return o.PqOnBackpressure
}

func (o *Output401) GetPqPath() *string {
	if o == nil {
		return nil
	}
	return o.PqPath
}

func (o *Output401) GetPqStrictOrdering() *bool {
	if o == nil {
		return nil
	}
	return o.PqStrictOrdering
}

func (o *Output401) GetPrometheusAuth() *Output401PrometheusAuth {
	if o == nil {
		return nil
	}
	return o.PrometheusAuth
}

func (o *Output401) GetPrometheusURL() string {
	if o == nil {
		return ""
	}
	return o.PrometheusURL
}

func (o *Output401) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *Output401) GetSafeHeaders() []string {
	if o == nil {
		return nil
	}
	return o.SafeHeaders
}

func (o *Output401) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *Output401) GetSystemFields() []string {
	if o == nil {
		return nil
	}
	return o.SystemFields
}

func (o *Output401) GetTimeoutSec() *int64 {
	if o == nil {
		return nil
	}
	return o.TimeoutSec
}

func (o *Output401) GetType() *Output401Type {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Output401) GetUseRoundRobinDNS() *bool {
	if o == nil {
		return nil
	}
	return o.UseRoundRobinDNS
}

type OutputType string

const (
	OutputTypeOutputDefault            OutputType = "OutputDefault"
	OutputTypeOutputWebhook            OutputType = "OutputWebhook"
	OutputTypeOutputDevnull            OutputType = "OutputDevnull"
	OutputTypeOutputSyslog             OutputType = "OutputSyslog"
	OutputTypeOutputSplunk             OutputType = "OutputSplunk"
	OutputTypeOutputSplunkLb           OutputType = "OutputSplunkLb"
	OutputTypeOutputSplunkHec          OutputType = "OutputSplunkHec"
	OutputTypeOutputTcpjson            OutputType = "OutputTcpjson"
	OutputTypeOutputWavefront          OutputType = "OutputWavefront"
	OutputTypeOutputSignalfx           OutputType = "OutputSignalfx"
	OutputTypeOutputFilesystem         OutputType = "OutputFilesystem"
	OutputTypeOutputS3                 OutputType = "OutputS3"
	OutputTypeOutputAzureBlob          OutputType = "OutputAzureBlob"
	OutputTypeOutputAzureLogs          OutputType = "OutputAzureLogs"
	OutputTypeOutputKinesis            OutputType = "OutputKinesis"
	OutputTypeOutputHoneycomb          OutputType = "OutputHoneycomb"
	OutputTypeOutputAzureEventhub      OutputType = "OutputAzureEventhub"
	OutputTypeOutputGoogleChronicle    OutputType = "OutputGoogleChronicle"
	OutputTypeOutputGoogleCloudStorage OutputType = "OutputGoogleCloudStorage"
	OutputTypeOutputGoogleCloudLogging OutputType = "OutputGoogleCloudLogging"
	OutputTypeOutputGooglePubsub       OutputType = "OutputGooglePubsub"
	OutputTypeOutputKafka              OutputType = "OutputKafka"
	OutputTypeOutputConfluentCloud     OutputType = "OutputConfluentCloud"
	OutputTypeOutputMsk                OutputType = "OutputMsk"
	OutputTypeOutputElastic            OutputType = "OutputElastic"
	OutputTypeOutputNewrelic           OutputType = "OutputNewrelic"
	OutputTypeOutputNewrelicEvents     OutputType = "OutputNewrelicEvents"
	OutputTypeOutputInfluxdb           OutputType = "OutputInfluxdb"
	OutputTypeOutputCloudwatch         OutputType = "OutputCloudwatch"
	OutputTypeOutputMinio              OutputType = "OutputMinio"
	OutputTypeOutputStatsd             OutputType = "OutputStatsd"
	OutputTypeOutputStatsdExt          OutputType = "OutputStatsdExt"
	OutputTypeOutputGraphite           OutputType = "OutputGraphite"
	OutputTypeOutputRouter             OutputType = "OutputRouter"
	OutputTypeOutputSns                OutputType = "OutputSns"
	OutputTypeOutputSqs                OutputType = "OutputSqs"
	OutputTypeOutputSnmp               OutputType = "OutputSnmp"
	OutputTypeOutputSumoLogic          OutputType = "OutputSumoLogic"
	OutputTypeOutputDatadog            OutputType = "OutputDatadog"
	OutputTypeAny                      OutputType = "any"
	OutputTypeOutputLoki               OutputType = "OutputLoki"
	OutputTypeOutputPrometheus         OutputType = "OutputPrometheus"
	OutputTypeOutputRing               OutputType = "OutputRing"
	OutputTypeOutputOpenTelemetry      OutputType = "OutputOpenTelemetry"
	OutputTypeOutputDataset            OutputType = "OutputDataset"
	OutputTypeOutputCriblTCP           OutputType = "OutputCriblTcp"
	OutputTypeOutputCriblHTTP          OutputType = "OutputCriblHttp"
	OutputTypeOutputHumioHec           OutputType = "OutputHumioHec"
	OutputTypeOutputDlS3               OutputType = "OutputDlS3"
	OutputTypeOutputSecurityLake       OutputType = "OutputSecurityLake"
)

type Output struct {
	OutputDefault            *OutputDefault
	OutputWebhook            *OutputWebhook
	OutputDevnull            *OutputDevnull
	OutputSyslog             *OutputSyslog
	OutputSplunk             *OutputSplunk
	OutputSplunkLb           *OutputSplunkLb
	OutputSplunkHec          *OutputSplunkHec
	OutputTcpjson            *OutputTcpjson
	OutputWavefront          *OutputWavefront
	OutputSignalfx           *OutputSignalfx
	OutputFilesystem         *OutputFilesystem
	OutputS3                 *OutputS3
	OutputAzureBlob          *OutputAzureBlob
	OutputAzureLogs          *OutputAzureLogs
	OutputKinesis            *OutputKinesis
	OutputHoneycomb          *OutputHoneycomb
	OutputAzureEventhub      *OutputAzureEventhub
	OutputGoogleChronicle    *OutputGoogleChronicle
	OutputGoogleCloudStorage *OutputGoogleCloudStorage
	OutputGoogleCloudLogging *OutputGoogleCloudLogging
	OutputGooglePubsub       *OutputGooglePubsub
	OutputKafka              *OutputKafka
	OutputConfluentCloud     *OutputConfluentCloud
	OutputMsk                *OutputMsk
	OutputElastic            *OutputElastic
	OutputNewrelic           *OutputNewrelic
	OutputNewrelicEvents     *OutputNewrelicEvents
	OutputInfluxdb           *OutputInfluxdb
	OutputCloudwatch         *OutputCloudwatch
	OutputMinio              *OutputMinio
	OutputStatsd             *OutputStatsd
	OutputStatsdExt          *OutputStatsdExt
	OutputGraphite           *OutputGraphite
	OutputRouter             *OutputRouter
	OutputSns                *OutputSns
	OutputSqs                *OutputSqs
	OutputSnmp               *OutputSnmp
	OutputSumoLogic          *OutputSumoLogic
	OutputDatadog            *OutputDatadog
	Any                      interface{}
	OutputLoki               *OutputLoki
	OutputPrometheus         *OutputPrometheus
	OutputRing               *OutputRing
	OutputOpenTelemetry      *OutputOpenTelemetry
	OutputDataset            *OutputDataset
	OutputCriblTCP           *OutputCriblTCP
	OutputCriblHTTP          *OutputCriblHTTP
	OutputHumioHec           *OutputHumioHec
	OutputDlS3               *OutputDlS3
	OutputSecurityLake       *OutputSecurityLake

	Type OutputType
}

func CreateOutputOutputDefault(outputDefault OutputDefault) Output {
	typ := OutputTypeOutputDefault

	return Output{
		OutputDefault: &outputDefault,
		Type:          typ,
	}
}

func CreateOutputOutputWebhook(outputWebhook OutputWebhook) Output {
	typ := OutputTypeOutputWebhook

	return Output{
		OutputWebhook: &outputWebhook,
		Type:          typ,
	}
}

func CreateOutputOutputDevnull(outputDevnull OutputDevnull) Output {
	typ := OutputTypeOutputDevnull

	return Output{
		OutputDevnull: &outputDevnull,
		Type:          typ,
	}
}

func CreateOutputOutputSyslog(outputSyslog OutputSyslog) Output {
	typ := OutputTypeOutputSyslog

	return Output{
		OutputSyslog: &outputSyslog,
		Type:         typ,
	}
}

func CreateOutputOutputSplunk(outputSplunk OutputSplunk) Output {
	typ := OutputTypeOutputSplunk

	return Output{
		OutputSplunk: &outputSplunk,
		Type:         typ,
	}
}

func CreateOutputOutputSplunkLb(outputSplunkLb OutputSplunkLb) Output {
	typ := OutputTypeOutputSplunkLb

	return Output{
		OutputSplunkLb: &outputSplunkLb,
		Type:           typ,
	}
}

func CreateOutputOutputSplunkHec(outputSplunkHec OutputSplunkHec) Output {
	typ := OutputTypeOutputSplunkHec

	return Output{
		OutputSplunkHec: &outputSplunkHec,
		Type:            typ,
	}
}

func CreateOutputOutputTcpjson(outputTcpjson OutputTcpjson) Output {
	typ := OutputTypeOutputTcpjson

	return Output{
		OutputTcpjson: &outputTcpjson,
		Type:          typ,
	}
}

func CreateOutputOutputWavefront(outputWavefront OutputWavefront) Output {
	typ := OutputTypeOutputWavefront

	return Output{
		OutputWavefront: &outputWavefront,
		Type:            typ,
	}
}

func CreateOutputOutputSignalfx(outputSignalfx OutputSignalfx) Output {
	typ := OutputTypeOutputSignalfx

	return Output{
		OutputSignalfx: &outputSignalfx,
		Type:           typ,
	}
}

func CreateOutputOutputFilesystem(outputFilesystem OutputFilesystem) Output {
	typ := OutputTypeOutputFilesystem

	return Output{
		OutputFilesystem: &outputFilesystem,
		Type:             typ,
	}
}

func CreateOutputOutputS3(outputS3 OutputS3) Output {
	typ := OutputTypeOutputS3

	return Output{
		OutputS3: &outputS3,
		Type:     typ,
	}
}

func CreateOutputOutputAzureBlob(outputAzureBlob OutputAzureBlob) Output {
	typ := OutputTypeOutputAzureBlob

	return Output{
		OutputAzureBlob: &outputAzureBlob,
		Type:            typ,
	}
}

func CreateOutputOutputAzureLogs(outputAzureLogs OutputAzureLogs) Output {
	typ := OutputTypeOutputAzureLogs

	return Output{
		OutputAzureLogs: &outputAzureLogs,
		Type:            typ,
	}
}

func CreateOutputOutputKinesis(outputKinesis OutputKinesis) Output {
	typ := OutputTypeOutputKinesis

	return Output{
		OutputKinesis: &outputKinesis,
		Type:          typ,
	}
}

func CreateOutputOutputHoneycomb(outputHoneycomb OutputHoneycomb) Output {
	typ := OutputTypeOutputHoneycomb

	return Output{
		OutputHoneycomb: &outputHoneycomb,
		Type:            typ,
	}
}

func CreateOutputOutputAzureEventhub(outputAzureEventhub OutputAzureEventhub) Output {
	typ := OutputTypeOutputAzureEventhub

	return Output{
		OutputAzureEventhub: &outputAzureEventhub,
		Type:                typ,
	}
}

func CreateOutputOutputGoogleChronicle(outputGoogleChronicle OutputGoogleChronicle) Output {
	typ := OutputTypeOutputGoogleChronicle

	return Output{
		OutputGoogleChronicle: &outputGoogleChronicle,
		Type:                  typ,
	}
}

func CreateOutputOutputGoogleCloudStorage(outputGoogleCloudStorage OutputGoogleCloudStorage) Output {
	typ := OutputTypeOutputGoogleCloudStorage

	return Output{
		OutputGoogleCloudStorage: &outputGoogleCloudStorage,
		Type:                     typ,
	}
}

func CreateOutputOutputGoogleCloudLogging(outputGoogleCloudLogging OutputGoogleCloudLogging) Output {
	typ := OutputTypeOutputGoogleCloudLogging

	return Output{
		OutputGoogleCloudLogging: &outputGoogleCloudLogging,
		Type:                     typ,
	}
}

func CreateOutputOutputGooglePubsub(outputGooglePubsub OutputGooglePubsub) Output {
	typ := OutputTypeOutputGooglePubsub

	return Output{
		OutputGooglePubsub: &outputGooglePubsub,
		Type:               typ,
	}
}

func CreateOutputOutputKafka(outputKafka OutputKafka) Output {
	typ := OutputTypeOutputKafka

	return Output{
		OutputKafka: &outputKafka,
		Type:        typ,
	}
}

func CreateOutputOutputConfluentCloud(outputConfluentCloud OutputConfluentCloud) Output {
	typ := OutputTypeOutputConfluentCloud

	return Output{
		OutputConfluentCloud: &outputConfluentCloud,
		Type:                 typ,
	}
}

func CreateOutputOutputMsk(outputMsk OutputMsk) Output {
	typ := OutputTypeOutputMsk

	return Output{
		OutputMsk: &outputMsk,
		Type:      typ,
	}
}

func CreateOutputOutputElastic(outputElastic OutputElastic) Output {
	typ := OutputTypeOutputElastic

	return Output{
		OutputElastic: &outputElastic,
		Type:          typ,
	}
}

func CreateOutputOutputNewrelic(outputNewrelic OutputNewrelic) Output {
	typ := OutputTypeOutputNewrelic

	return Output{
		OutputNewrelic: &outputNewrelic,
		Type:           typ,
	}
}

func CreateOutputOutputNewrelicEvents(outputNewrelicEvents OutputNewrelicEvents) Output {
	typ := OutputTypeOutputNewrelicEvents

	return Output{
		OutputNewrelicEvents: &outputNewrelicEvents,
		Type:                 typ,
	}
}

func CreateOutputOutputInfluxdb(outputInfluxdb OutputInfluxdb) Output {
	typ := OutputTypeOutputInfluxdb

	return Output{
		OutputInfluxdb: &outputInfluxdb,
		Type:           typ,
	}
}

func CreateOutputOutputCloudwatch(outputCloudwatch OutputCloudwatch) Output {
	typ := OutputTypeOutputCloudwatch

	return Output{
		OutputCloudwatch: &outputCloudwatch,
		Type:             typ,
	}
}

func CreateOutputOutputMinio(outputMinio OutputMinio) Output {
	typ := OutputTypeOutputMinio

	return Output{
		OutputMinio: &outputMinio,
		Type:        typ,
	}
}

func CreateOutputOutputStatsd(outputStatsd OutputStatsd) Output {
	typ := OutputTypeOutputStatsd

	return Output{
		OutputStatsd: &outputStatsd,
		Type:         typ,
	}
}

func CreateOutputOutputStatsdExt(outputStatsdExt OutputStatsdExt) Output {
	typ := OutputTypeOutputStatsdExt

	return Output{
		OutputStatsdExt: &outputStatsdExt,
		Type:            typ,
	}
}

func CreateOutputOutputGraphite(outputGraphite OutputGraphite) Output {
	typ := OutputTypeOutputGraphite

	return Output{
		OutputGraphite: &outputGraphite,
		Type:           typ,
	}
}

func CreateOutputOutputRouter(outputRouter OutputRouter) Output {
	typ := OutputTypeOutputRouter

	return Output{
		OutputRouter: &outputRouter,
		Type:         typ,
	}
}

func CreateOutputOutputSns(outputSns OutputSns) Output {
	typ := OutputTypeOutputSns

	return Output{
		OutputSns: &outputSns,
		Type:      typ,
	}
}

func CreateOutputOutputSqs(outputSqs OutputSqs) Output {
	typ := OutputTypeOutputSqs

	return Output{
		OutputSqs: &outputSqs,
		Type:      typ,
	}
}

func CreateOutputOutputSnmp(outputSnmp OutputSnmp) Output {
	typ := OutputTypeOutputSnmp

	return Output{
		OutputSnmp: &outputSnmp,
		Type:       typ,
	}
}

func CreateOutputOutputSumoLogic(outputSumoLogic OutputSumoLogic) Output {
	typ := OutputTypeOutputSumoLogic

	return Output{
		OutputSumoLogic: &outputSumoLogic,
		Type:            typ,
	}
}

func CreateOutputOutputDatadog(outputDatadog OutputDatadog) Output {
	typ := OutputTypeOutputDatadog

	return Output{
		OutputDatadog: &outputDatadog,
		Type:          typ,
	}
}

func CreateOutputAny(any interface{}) Output {
	typ := OutputTypeAny

	return Output{
		Any:  &any,
		Type: typ,
	}
}

func CreateOutputOutputLoki(outputLoki OutputLoki) Output {
	typ := OutputTypeOutputLoki

	return Output{
		OutputLoki: &outputLoki,
		Type:       typ,
	}
}

func CreateOutputOutputPrometheus(outputPrometheus OutputPrometheus) Output {
	typ := OutputTypeOutputPrometheus

	return Output{
		OutputPrometheus: &outputPrometheus,
		Type:             typ,
	}
}

func CreateOutputOutputRing(outputRing OutputRing) Output {
	typ := OutputTypeOutputRing

	return Output{
		OutputRing: &outputRing,
		Type:       typ,
	}
}

func CreateOutputOutputOpenTelemetry(outputOpenTelemetry OutputOpenTelemetry) Output {
	typ := OutputTypeOutputOpenTelemetry

	return Output{
		OutputOpenTelemetry: &outputOpenTelemetry,
		Type:                typ,
	}
}

func CreateOutputOutputDataset(outputDataset OutputDataset) Output {
	typ := OutputTypeOutputDataset

	return Output{
		OutputDataset: &outputDataset,
		Type:          typ,
	}
}

func CreateOutputOutputCriblTCP(outputCriblTCP OutputCriblTCP) Output {
	typ := OutputTypeOutputCriblTCP

	return Output{
		OutputCriblTCP: &outputCriblTCP,
		Type:           typ,
	}
}

func CreateOutputOutputCriblHTTP(outputCriblHTTP OutputCriblHTTP) Output {
	typ := OutputTypeOutputCriblHTTP

	return Output{
		OutputCriblHTTP: &outputCriblHTTP,
		Type:            typ,
	}
}

func CreateOutputOutputHumioHec(outputHumioHec OutputHumioHec) Output {
	typ := OutputTypeOutputHumioHec

	return Output{
		OutputHumioHec: &outputHumioHec,
		Type:           typ,
	}
}

func CreateOutputOutputDlS3(outputDlS3 OutputDlS3) Output {
	typ := OutputTypeOutputDlS3

	return Output{
		OutputDlS3: &outputDlS3,
		Type:       typ,
	}
}

func CreateOutputOutputSecurityLake(outputSecurityLake OutputSecurityLake) Output {
	typ := OutputTypeOutputSecurityLake

	return Output{
		OutputSecurityLake: &outputSecurityLake,
		Type:               typ,
	}
}

func (u *Output) UnmarshalJSON(data []byte) error {
	var d *json.Decoder

	outputDefault := new(OutputDefault)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputDefault); err == nil {
		u.OutputDefault = outputDefault
		u.Type = OutputTypeOutputDefault
		return nil
	}

	outputWebhook := new(OutputWebhook)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputWebhook); err == nil {
		u.OutputWebhook = outputWebhook
		u.Type = OutputTypeOutputWebhook
		return nil
	}

	outputDevnull := new(OutputDevnull)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputDevnull); err == nil {
		u.OutputDevnull = outputDevnull
		u.Type = OutputTypeOutputDevnull
		return nil
	}

	outputSyslog := new(OutputSyslog)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSyslog); err == nil {
		u.OutputSyslog = outputSyslog
		u.Type = OutputTypeOutputSyslog
		return nil
	}

	outputSplunk := new(OutputSplunk)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSplunk); err == nil {
		u.OutputSplunk = outputSplunk
		u.Type = OutputTypeOutputSplunk
		return nil
	}

	outputSplunkLb := new(OutputSplunkLb)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSplunkLb); err == nil {
		u.OutputSplunkLb = outputSplunkLb
		u.Type = OutputTypeOutputSplunkLb
		return nil
	}

	outputSplunkHec := new(OutputSplunkHec)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSplunkHec); err == nil {
		u.OutputSplunkHec = outputSplunkHec
		u.Type = OutputTypeOutputSplunkHec
		return nil
	}

	outputTcpjson := new(OutputTcpjson)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputTcpjson); err == nil {
		u.OutputTcpjson = outputTcpjson
		u.Type = OutputTypeOutputTcpjson
		return nil
	}

	outputWavefront := new(OutputWavefront)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputWavefront); err == nil {
		u.OutputWavefront = outputWavefront
		u.Type = OutputTypeOutputWavefront
		return nil
	}

	outputSignalfx := new(OutputSignalfx)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSignalfx); err == nil {
		u.OutputSignalfx = outputSignalfx
		u.Type = OutputTypeOutputSignalfx
		return nil
	}

	outputFilesystem := new(OutputFilesystem)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputFilesystem); err == nil {
		u.OutputFilesystem = outputFilesystem
		u.Type = OutputTypeOutputFilesystem
		return nil
	}

	outputS3 := new(OutputS3)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputS3); err == nil {
		u.OutputS3 = outputS3
		u.Type = OutputTypeOutputS3
		return nil
	}

	outputAzureBlob := new(OutputAzureBlob)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputAzureBlob); err == nil {
		u.OutputAzureBlob = outputAzureBlob
		u.Type = OutputTypeOutputAzureBlob
		return nil
	}

	outputAzureLogs := new(OutputAzureLogs)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputAzureLogs); err == nil {
		u.OutputAzureLogs = outputAzureLogs
		u.Type = OutputTypeOutputAzureLogs
		return nil
	}

	outputKinesis := new(OutputKinesis)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputKinesis); err == nil {
		u.OutputKinesis = outputKinesis
		u.Type = OutputTypeOutputKinesis
		return nil
	}

	outputHoneycomb := new(OutputHoneycomb)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputHoneycomb); err == nil {
		u.OutputHoneycomb = outputHoneycomb
		u.Type = OutputTypeOutputHoneycomb
		return nil
	}

	outputAzureEventhub := new(OutputAzureEventhub)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputAzureEventhub); err == nil {
		u.OutputAzureEventhub = outputAzureEventhub
		u.Type = OutputTypeOutputAzureEventhub
		return nil
	}

	outputGoogleChronicle := new(OutputGoogleChronicle)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputGoogleChronicle); err == nil {
		u.OutputGoogleChronicle = outputGoogleChronicle
		u.Type = OutputTypeOutputGoogleChronicle
		return nil
	}

	outputGoogleCloudStorage := new(OutputGoogleCloudStorage)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputGoogleCloudStorage); err == nil {
		u.OutputGoogleCloudStorage = outputGoogleCloudStorage
		u.Type = OutputTypeOutputGoogleCloudStorage
		return nil
	}

	outputGoogleCloudLogging := new(OutputGoogleCloudLogging)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputGoogleCloudLogging); err == nil {
		u.OutputGoogleCloudLogging = outputGoogleCloudLogging
		u.Type = OutputTypeOutputGoogleCloudLogging
		return nil
	}

	outputGooglePubsub := new(OutputGooglePubsub)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputGooglePubsub); err == nil {
		u.OutputGooglePubsub = outputGooglePubsub
		u.Type = OutputTypeOutputGooglePubsub
		return nil
	}

	outputKafka := new(OutputKafka)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputKafka); err == nil {
		u.OutputKafka = outputKafka
		u.Type = OutputTypeOutputKafka
		return nil
	}

	outputConfluentCloud := new(OutputConfluentCloud)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputConfluentCloud); err == nil {
		u.OutputConfluentCloud = outputConfluentCloud
		u.Type = OutputTypeOutputConfluentCloud
		return nil
	}

	outputMsk := new(OutputMsk)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputMsk); err == nil {
		u.OutputMsk = outputMsk
		u.Type = OutputTypeOutputMsk
		return nil
	}

	outputElastic := new(OutputElastic)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputElastic); err == nil {
		u.OutputElastic = outputElastic
		u.Type = OutputTypeOutputElastic
		return nil
	}

	outputNewrelic := new(OutputNewrelic)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputNewrelic); err == nil {
		u.OutputNewrelic = outputNewrelic
		u.Type = OutputTypeOutputNewrelic
		return nil
	}

	outputNewrelicEvents := new(OutputNewrelicEvents)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputNewrelicEvents); err == nil {
		u.OutputNewrelicEvents = outputNewrelicEvents
		u.Type = OutputTypeOutputNewrelicEvents
		return nil
	}

	outputInfluxdb := new(OutputInfluxdb)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputInfluxdb); err == nil {
		u.OutputInfluxdb = outputInfluxdb
		u.Type = OutputTypeOutputInfluxdb
		return nil
	}

	outputCloudwatch := new(OutputCloudwatch)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputCloudwatch); err == nil {
		u.OutputCloudwatch = outputCloudwatch
		u.Type = OutputTypeOutputCloudwatch
		return nil
	}

	outputMinio := new(OutputMinio)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputMinio); err == nil {
		u.OutputMinio = outputMinio
		u.Type = OutputTypeOutputMinio
		return nil
	}

	outputStatsd := new(OutputStatsd)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputStatsd); err == nil {
		u.OutputStatsd = outputStatsd
		u.Type = OutputTypeOutputStatsd
		return nil
	}

	outputStatsdExt := new(OutputStatsdExt)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputStatsdExt); err == nil {
		u.OutputStatsdExt = outputStatsdExt
		u.Type = OutputTypeOutputStatsdExt
		return nil
	}

	outputGraphite := new(OutputGraphite)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputGraphite); err == nil {
		u.OutputGraphite = outputGraphite
		u.Type = OutputTypeOutputGraphite
		return nil
	}

	outputRouter := new(OutputRouter)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputRouter); err == nil {
		u.OutputRouter = outputRouter
		u.Type = OutputTypeOutputRouter
		return nil
	}

	outputSns := new(OutputSns)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSns); err == nil {
		u.OutputSns = outputSns
		u.Type = OutputTypeOutputSns
		return nil
	}

	outputSqs := new(OutputSqs)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSqs); err == nil {
		u.OutputSqs = outputSqs
		u.Type = OutputTypeOutputSqs
		return nil
	}

	outputSnmp := new(OutputSnmp)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSnmp); err == nil {
		u.OutputSnmp = outputSnmp
		u.Type = OutputTypeOutputSnmp
		return nil
	}

	outputSumoLogic := new(OutputSumoLogic)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSumoLogic); err == nil {
		u.OutputSumoLogic = outputSumoLogic
		u.Type = OutputTypeOutputSumoLogic
		return nil
	}

	outputDatadog := new(OutputDatadog)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputDatadog); err == nil {
		u.OutputDatadog = outputDatadog
		u.Type = OutputTypeOutputDatadog
		return nil
	}

	any := new(interface{})
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&any); err == nil {
		u.Any = any
		u.Type = OutputTypeAny
		return nil
	}

	outputLoki := new(OutputLoki)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputLoki); err == nil {
		u.OutputLoki = outputLoki
		u.Type = OutputTypeOutputLoki
		return nil
	}

	outputPrometheus := new(OutputPrometheus)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputPrometheus); err == nil {
		u.OutputPrometheus = outputPrometheus
		u.Type = OutputTypeOutputPrometheus
		return nil
	}

	outputRing := new(OutputRing)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputRing); err == nil {
		u.OutputRing = outputRing
		u.Type = OutputTypeOutputRing
		return nil
	}

	outputOpenTelemetry := new(OutputOpenTelemetry)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputOpenTelemetry); err == nil {
		u.OutputOpenTelemetry = outputOpenTelemetry
		u.Type = OutputTypeOutputOpenTelemetry
		return nil
	}

	outputDataset := new(OutputDataset)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputDataset); err == nil {
		u.OutputDataset = outputDataset
		u.Type = OutputTypeOutputDataset
		return nil
	}

	outputCriblTCP := new(OutputCriblTCP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputCriblTCP); err == nil {
		u.OutputCriblTCP = outputCriblTCP
		u.Type = OutputTypeOutputCriblTCP
		return nil
	}

	outputCriblHTTP := new(OutputCriblHTTP)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputCriblHTTP); err == nil {
		u.OutputCriblHTTP = outputCriblHTTP
		u.Type = OutputTypeOutputCriblHTTP
		return nil
	}

	outputHumioHec := new(OutputHumioHec)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputHumioHec); err == nil {
		u.OutputHumioHec = outputHumioHec
		u.Type = OutputTypeOutputHumioHec
		return nil
	}

	outputDlS3 := new(OutputDlS3)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputDlS3); err == nil {
		u.OutputDlS3 = outputDlS3
		u.Type = OutputTypeOutputDlS3
		return nil
	}

	outputSecurityLake := new(OutputSecurityLake)
	d = json.NewDecoder(bytes.NewReader(data))
	d.DisallowUnknownFields()
	if err := d.Decode(&outputSecurityLake); err == nil {
		u.OutputSecurityLake = outputSecurityLake
		u.Type = OutputTypeOutputSecurityLake
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u Output) MarshalJSON() ([]byte, error) {
	if u.OutputDefault != nil {
		return json.Marshal(u.OutputDefault)
	}

	if u.OutputWebhook != nil {
		return json.Marshal(u.OutputWebhook)
	}

	if u.OutputDevnull != nil {
		return json.Marshal(u.OutputDevnull)
	}

	if u.OutputSyslog != nil {
		return json.Marshal(u.OutputSyslog)
	}

	if u.OutputSplunk != nil {
		return json.Marshal(u.OutputSplunk)
	}

	if u.OutputSplunkLb != nil {
		return json.Marshal(u.OutputSplunkLb)
	}

	if u.OutputSplunkHec != nil {
		return json.Marshal(u.OutputSplunkHec)
	}

	if u.OutputTcpjson != nil {
		return json.Marshal(u.OutputTcpjson)
	}

	if u.OutputWavefront != nil {
		return json.Marshal(u.OutputWavefront)
	}

	if u.OutputSignalfx != nil {
		return json.Marshal(u.OutputSignalfx)
	}

	if u.OutputFilesystem != nil {
		return json.Marshal(u.OutputFilesystem)
	}

	if u.OutputS3 != nil {
		return json.Marshal(u.OutputS3)
	}

	if u.OutputAzureBlob != nil {
		return json.Marshal(u.OutputAzureBlob)
	}

	if u.OutputAzureLogs != nil {
		return json.Marshal(u.OutputAzureLogs)
	}

	if u.OutputKinesis != nil {
		return json.Marshal(u.OutputKinesis)
	}

	if u.OutputHoneycomb != nil {
		return json.Marshal(u.OutputHoneycomb)
	}

	if u.OutputAzureEventhub != nil {
		return json.Marshal(u.OutputAzureEventhub)
	}

	if u.OutputGoogleChronicle != nil {
		return json.Marshal(u.OutputGoogleChronicle)
	}

	if u.OutputGoogleCloudStorage != nil {
		return json.Marshal(u.OutputGoogleCloudStorage)
	}

	if u.OutputGoogleCloudLogging != nil {
		return json.Marshal(u.OutputGoogleCloudLogging)
	}

	if u.OutputGooglePubsub != nil {
		return json.Marshal(u.OutputGooglePubsub)
	}

	if u.OutputKafka != nil {
		return json.Marshal(u.OutputKafka)
	}

	if u.OutputConfluentCloud != nil {
		return json.Marshal(u.OutputConfluentCloud)
	}

	if u.OutputMsk != nil {
		return json.Marshal(u.OutputMsk)
	}

	if u.OutputElastic != nil {
		return json.Marshal(u.OutputElastic)
	}

	if u.OutputNewrelic != nil {
		return json.Marshal(u.OutputNewrelic)
	}

	if u.OutputNewrelicEvents != nil {
		return json.Marshal(u.OutputNewrelicEvents)
	}

	if u.OutputInfluxdb != nil {
		return json.Marshal(u.OutputInfluxdb)
	}

	if u.OutputCloudwatch != nil {
		return json.Marshal(u.OutputCloudwatch)
	}

	if u.OutputMinio != nil {
		return json.Marshal(u.OutputMinio)
	}

	if u.OutputStatsd != nil {
		return json.Marshal(u.OutputStatsd)
	}

	if u.OutputStatsdExt != nil {
		return json.Marshal(u.OutputStatsdExt)
	}

	if u.OutputGraphite != nil {
		return json.Marshal(u.OutputGraphite)
	}

	if u.OutputRouter != nil {
		return json.Marshal(u.OutputRouter)
	}

	if u.OutputSns != nil {
		return json.Marshal(u.OutputSns)
	}

	if u.OutputSqs != nil {
		return json.Marshal(u.OutputSqs)
	}

	if u.OutputSnmp != nil {
		return json.Marshal(u.OutputSnmp)
	}

	if u.OutputSumoLogic != nil {
		return json.Marshal(u.OutputSumoLogic)
	}

	if u.OutputDatadog != nil {
		return json.Marshal(u.OutputDatadog)
	}

	if u.Any != nil {
		return json.Marshal(u.Any)
	}

	if u.OutputLoki != nil {
		return json.Marshal(u.OutputLoki)
	}

	if u.OutputPrometheus != nil {
		return json.Marshal(u.OutputPrometheus)
	}

	if u.OutputRing != nil {
		return json.Marshal(u.OutputRing)
	}

	if u.OutputOpenTelemetry != nil {
		return json.Marshal(u.OutputOpenTelemetry)
	}

	if u.OutputDataset != nil {
		return json.Marshal(u.OutputDataset)
	}

	if u.OutputCriblTCP != nil {
		return json.Marshal(u.OutputCriblTCP)
	}

	if u.OutputCriblHTTP != nil {
		return json.Marshal(u.OutputCriblHTTP)
	}

	if u.OutputHumioHec != nil {
		return json.Marshal(u.OutputHumioHec)
	}

	if u.OutputDlS3 != nil {
		return json.Marshal(u.OutputDlS3)
	}

	if u.OutputSecurityLake != nil {
		return json.Marshal(u.OutputSecurityLake)
	}

	return nil, nil
}
