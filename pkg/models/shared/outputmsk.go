// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

// OutputMskAcknowledgments - Control the number of required acknowledgments.
type OutputMskAcknowledgments int64

const (
	OutputMskAcknowledgmentsOne    OutputMskAcknowledgments = 1
	OutputMskAcknowledgmentsZero   OutputMskAcknowledgments = 0
	OutputMskAcknowledgmentsMinus1 OutputMskAcknowledgments = -1
)

func (e OutputMskAcknowledgments) ToPointer() *OutputMskAcknowledgments {
	return &e
}

func (e *OutputMskAcknowledgments) UnmarshalJSON(data []byte) error {
	var v int64
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case 1:
		fallthrough
	case 0:
		fallthrough
	case -1:
		*e = OutputMskAcknowledgments(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskAcknowledgments: %v", v)
	}
}

// OutputMskAuthenticationMethod - AWS authentication method. Choose Auto to use IAM roles.
type OutputMskAuthenticationMethod string

const (
	OutputMskAuthenticationMethodSecret OutputMskAuthenticationMethod = "secret"
	OutputMskAuthenticationMethodManual OutputMskAuthenticationMethod = "manual"
)

func (e OutputMskAuthenticationMethod) ToPointer() *OutputMskAuthenticationMethod {
	return &e
}

func (e *OutputMskAuthenticationMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "secret":
		fallthrough
	case "manual":
		*e = OutputMskAuthenticationMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskAuthenticationMethod: %v", v)
	}
}

// OutputMskCompression - Codec to use to compress the data before sending to Kafka
type OutputMskCompression string

const (
	OutputMskCompressionNone   OutputMskCompression = "none"
	OutputMskCompressionGzip   OutputMskCompression = "gzip"
	OutputMskCompressionSnappy OutputMskCompression = "snappy"
	OutputMskCompressionLz4    OutputMskCompression = "lz4"
)

func (e OutputMskCompression) ToPointer() *OutputMskCompression {
	return &e
}

func (e *OutputMskCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		fallthrough
	case "snappy":
		fallthrough
	case "lz4":
		*e = OutputMskCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskCompression: %v", v)
	}
}

// OutputMskRecordDataFormat - Format to use to serialize events before writing to Kafka.
type OutputMskRecordDataFormat string

const (
	OutputMskRecordDataFormatJSON OutputMskRecordDataFormat = "json"
	OutputMskRecordDataFormatRaw  OutputMskRecordDataFormat = "raw"
)

func (e OutputMskRecordDataFormat) ToPointer() *OutputMskRecordDataFormat {
	return &e
}

func (e *OutputMskRecordDataFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "raw":
		*e = OutputMskRecordDataFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskRecordDataFormat: %v", v)
	}
}

// OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion - Maximum TLS version to use when connecting
type OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion string

const (
	OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersionTlSv1  OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion = "TLSv1"
	OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersionTlSv11 OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion = "TLSv1.1"
	OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersionTlSv12 OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion = "TLSv1.2"
	OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersionTlSv13 OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion = "TLSv1.3"
)

func (e OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion) ToPointer() *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion {
	return &e
}

func (e *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion: %v", v)
	}
}

// OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion - Minimum TLS version to use when connecting
type OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion string

const (
	OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersionTlSv1  OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion = "TLSv1"
	OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersionTlSv11 OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion = "TLSv1.1"
	OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersionTlSv12 OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion = "TLSv1.2"
	OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersionTlSv13 OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion = "TLSv1.3"
)

func (e OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion) ToPointer() *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion {
	return &e
}

func (e *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion: %v", v)
	}
}

type OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide struct {
	// Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	Disabled        *bool   `json:"disabled,omitempty"`
	// Maximum TLS version to use when connecting
	MaxVersion *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to use when connecting
	MinVersion *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath *string `json:"privKeyPath,omitempty"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Defaults to No.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
	Servername *string `json:"servername,omitempty"`
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetCaPath() *string {
	if o == nil {
		return nil
	}
	return o.CaPath
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetCertPath() *string {
	if o == nil {
		return nil
	}
	return o.CertPath
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetCertificateName() *string {
	if o == nil {
		return nil
	}
	return o.CertificateName
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetMaxVersion() *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetMinVersion() *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSideMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetPassphrase() *string {
	if o == nil {
		return nil
	}
	return o.Passphrase
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetPrivKeyPath() *string {
	if o == nil {
		return nil
	}
	return o.PrivKeyPath
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide) GetServername() *string {
	if o == nil {
		return nil
	}
	return o.Servername
}

type OutputMskKafkaSchemaRegistryAuthentication struct {
	// Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
	DefaultKeySchemaID *int64 `json:"defaultKeySchemaId,omitempty"`
	// Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
	DefaultValueSchemaID *int64 `json:"defaultValueSchemaId,omitempty"`
	// Enable Schema Registry
	Disabled bool `json:"disabled"`
	// URL for access to the Confluent Schema Registry, i.e.: http://localhost:8081
	SchemaRegistryURL *string                                                          `json:"schemaRegistryURL,omitempty"`
	TLS               *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide `json:"tls,omitempty"`
}

func (o *OutputMskKafkaSchemaRegistryAuthentication) GetDefaultKeySchemaID() *int64 {
	if o == nil {
		return nil
	}
	return o.DefaultKeySchemaID
}

func (o *OutputMskKafkaSchemaRegistryAuthentication) GetDefaultValueSchemaID() *int64 {
	if o == nil {
		return nil
	}
	return o.DefaultValueSchemaID
}

func (o *OutputMskKafkaSchemaRegistryAuthentication) GetDisabled() bool {
	if o == nil {
		return false
	}
	return o.Disabled
}

func (o *OutputMskKafkaSchemaRegistryAuthentication) GetSchemaRegistryURL() *string {
	if o == nil {
		return nil
	}
	return o.SchemaRegistryURL
}

func (o *OutputMskKafkaSchemaRegistryAuthentication) GetTLS() *OutputMskKafkaSchemaRegistryAuthenticationTLSSettingsClientSide {
	if o == nil {
		return nil
	}
	return o.TLS
}

// OutputMskBackpressureBehavior - Whether to block, drop, or queue events when all receivers are exerting backpressure.
type OutputMskBackpressureBehavior string

const (
	OutputMskBackpressureBehaviorQueue OutputMskBackpressureBehavior = "queue"
	OutputMskBackpressureBehaviorDrop  OutputMskBackpressureBehavior = "drop"
	OutputMskBackpressureBehaviorBlock OutputMskBackpressureBehavior = "block"
)

func (e OutputMskBackpressureBehavior) ToPointer() *OutputMskBackpressureBehavior {
	return &e
}

func (e *OutputMskBackpressureBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "queue":
		fallthrough
	case "drop":
		fallthrough
	case "block":
		*e = OutputMskBackpressureBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskBackpressureBehavior: %v", v)
	}
}

// OutputMskCompression1 - Codec to use to compress the persisted data.
type OutputMskCompression1 string

const (
	OutputMskCompression1None OutputMskCompression1 = "none"
	OutputMskCompression1Gzip OutputMskCompression1 = "gzip"
)

func (e OutputMskCompression1) ToPointer() *OutputMskCompression1 {
	return &e
}

func (e *OutputMskCompression1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = OutputMskCompression1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskCompression1: %v", v)
	}
}

type OutputMskPqControls struct {
}

// OutputMskQueueFullBehavior - Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
type OutputMskQueueFullBehavior string

const (
	OutputMskQueueFullBehaviorBlock OutputMskQueueFullBehavior = "block"
	OutputMskQueueFullBehaviorDrop  OutputMskQueueFullBehavior = "drop"
)

func (e OutputMskQueueFullBehavior) ToPointer() *OutputMskQueueFullBehavior {
	return &e
}

func (e *OutputMskQueueFullBehavior) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "drop":
		*e = OutputMskQueueFullBehavior(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskQueueFullBehavior: %v", v)
	}
}

// OutputMskRegion - Region where the MSK cluster is located
type OutputMskRegion string

const (
	OutputMskRegionUsEast1      OutputMskRegion = "us-east-1"
	OutputMskRegionUsEast2      OutputMskRegion = "us-east-2"
	OutputMskRegionUsWest1      OutputMskRegion = "us-west-1"
	OutputMskRegionUsWest2      OutputMskRegion = "us-west-2"
	OutputMskRegionAfSouth1     OutputMskRegion = "af-south-1"
	OutputMskRegionCaCentral1   OutputMskRegion = "ca-central-1"
	OutputMskRegionEuWest1      OutputMskRegion = "eu-west-1"
	OutputMskRegionEuCentral1   OutputMskRegion = "eu-central-1"
	OutputMskRegionEuWest2      OutputMskRegion = "eu-west-2"
	OutputMskRegionEuSouth1     OutputMskRegion = "eu-south-1"
	OutputMskRegionEuWest3      OutputMskRegion = "eu-west-3"
	OutputMskRegionEuNorth1     OutputMskRegion = "eu-north-1"
	OutputMskRegionApEast1      OutputMskRegion = "ap-east-1"
	OutputMskRegionApNortheast1 OutputMskRegion = "ap-northeast-1"
	OutputMskRegionApNortheast2 OutputMskRegion = "ap-northeast-2"
	OutputMskRegionApSoutheast1 OutputMskRegion = "ap-southeast-1"
	OutputMskRegionApSoutheast2 OutputMskRegion = "ap-southeast-2"
	OutputMskRegionApSouth1     OutputMskRegion = "ap-south-1"
	OutputMskRegionMeSouth1     OutputMskRegion = "me-south-1"
	OutputMskRegionSaEast1      OutputMskRegion = "sa-east-1"
	OutputMskRegionUsGovEast1   OutputMskRegion = "us-gov-east-1"
	OutputMskRegionUsGovWest1   OutputMskRegion = "us-gov-west-1"
)

func (e OutputMskRegion) ToPointer() *OutputMskRegion {
	return &e
}

func (e *OutputMskRegion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "us-east-1":
		fallthrough
	case "us-east-2":
		fallthrough
	case "us-west-1":
		fallthrough
	case "us-west-2":
		fallthrough
	case "af-south-1":
		fallthrough
	case "ca-central-1":
		fallthrough
	case "eu-west-1":
		fallthrough
	case "eu-central-1":
		fallthrough
	case "eu-west-2":
		fallthrough
	case "eu-south-1":
		fallthrough
	case "eu-west-3":
		fallthrough
	case "eu-north-1":
		fallthrough
	case "ap-east-1":
		fallthrough
	case "ap-northeast-1":
		fallthrough
	case "ap-northeast-2":
		fallthrough
	case "ap-southeast-1":
		fallthrough
	case "ap-southeast-2":
		fallthrough
	case "ap-south-1":
		fallthrough
	case "me-south-1":
		fallthrough
	case "sa-east-1":
		fallthrough
	case "us-gov-east-1":
		fallthrough
	case "us-gov-west-1":
		*e = OutputMskRegion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskRegion: %v", v)
	}
}

// OutputMskSignatureVersion - Signature version to use for signing MSK cluster requests.
type OutputMskSignatureVersion string

const (
	OutputMskSignatureVersionV2 OutputMskSignatureVersion = "v2"
	OutputMskSignatureVersionV4 OutputMskSignatureVersion = "v4"
)

func (e OutputMskSignatureVersion) ToPointer() *OutputMskSignatureVersion {
	return &e
}

func (e *OutputMskSignatureVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v2":
		fallthrough
	case "v4":
		*e = OutputMskSignatureVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskSignatureVersion: %v", v)
	}
}

// OutputMskTLSSettingsClientSideMaximumTLSVersion - Maximum TLS version to use when connecting
type OutputMskTLSSettingsClientSideMaximumTLSVersion string

const (
	OutputMskTLSSettingsClientSideMaximumTLSVersionTlSv1  OutputMskTLSSettingsClientSideMaximumTLSVersion = "TLSv1"
	OutputMskTLSSettingsClientSideMaximumTLSVersionTlSv11 OutputMskTLSSettingsClientSideMaximumTLSVersion = "TLSv1.1"
	OutputMskTLSSettingsClientSideMaximumTLSVersionTlSv12 OutputMskTLSSettingsClientSideMaximumTLSVersion = "TLSv1.2"
	OutputMskTLSSettingsClientSideMaximumTLSVersionTlSv13 OutputMskTLSSettingsClientSideMaximumTLSVersion = "TLSv1.3"
)

func (e OutputMskTLSSettingsClientSideMaximumTLSVersion) ToPointer() *OutputMskTLSSettingsClientSideMaximumTLSVersion {
	return &e
}

func (e *OutputMskTLSSettingsClientSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputMskTLSSettingsClientSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskTLSSettingsClientSideMaximumTLSVersion: %v", v)
	}
}

// OutputMskTLSSettingsClientSideMinimumTLSVersion - Minimum TLS version to use when connecting
type OutputMskTLSSettingsClientSideMinimumTLSVersion string

const (
	OutputMskTLSSettingsClientSideMinimumTLSVersionTlSv1  OutputMskTLSSettingsClientSideMinimumTLSVersion = "TLSv1"
	OutputMskTLSSettingsClientSideMinimumTLSVersionTlSv11 OutputMskTLSSettingsClientSideMinimumTLSVersion = "TLSv1.1"
	OutputMskTLSSettingsClientSideMinimumTLSVersionTlSv12 OutputMskTLSSettingsClientSideMinimumTLSVersion = "TLSv1.2"
	OutputMskTLSSettingsClientSideMinimumTLSVersionTlSv13 OutputMskTLSSettingsClientSideMinimumTLSVersion = "TLSv1.3"
)

func (e OutputMskTLSSettingsClientSideMinimumTLSVersion) ToPointer() *OutputMskTLSSettingsClientSideMinimumTLSVersion {
	return &e
}

func (e *OutputMskTLSSettingsClientSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = OutputMskTLSSettingsClientSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskTLSSettingsClientSideMinimumTLSVersion: %v", v)
	}
}

type OutputMskTLSSettingsClientSide struct {
	// Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string `json:"certificateName,omitempty"`
	Disabled        *bool   `json:"disabled,omitempty"`
	// Maximum TLS version to use when connecting
	MaxVersion *OutputMskTLSSettingsClientSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to use when connecting
	MinVersion *OutputMskTLSSettingsClientSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath *string `json:"privKeyPath,omitempty"`
	// Reject certs that are not authorized by a CA in the CA certificate path, or by another trusted CA (e.g., the system's CA). Defaults to No.
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
	Servername *string `json:"servername,omitempty"`
}

func (o *OutputMskTLSSettingsClientSide) GetCaPath() *string {
	if o == nil {
		return nil
	}
	return o.CaPath
}

func (o *OutputMskTLSSettingsClientSide) GetCertPath() *string {
	if o == nil {
		return nil
	}
	return o.CertPath
}

func (o *OutputMskTLSSettingsClientSide) GetCertificateName() *string {
	if o == nil {
		return nil
	}
	return o.CertificateName
}

func (o *OutputMskTLSSettingsClientSide) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *OutputMskTLSSettingsClientSide) GetMaxVersion() *OutputMskTLSSettingsClientSideMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

func (o *OutputMskTLSSettingsClientSide) GetMinVersion() *OutputMskTLSSettingsClientSideMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *OutputMskTLSSettingsClientSide) GetPassphrase() *string {
	if o == nil {
		return nil
	}
	return o.Passphrase
}

func (o *OutputMskTLSSettingsClientSide) GetPrivKeyPath() *string {
	if o == nil {
		return nil
	}
	return o.PrivKeyPath
}

func (o *OutputMskTLSSettingsClientSide) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *OutputMskTLSSettingsClientSide) GetServername() *string {
	if o == nil {
		return nil
	}
	return o.Servername
}

type OutputMskType string

const (
	OutputMskTypeMsk OutputMskType = "msk"
)

func (e OutputMskType) ToPointer() *OutputMskType {
	return &e
}

func (e *OutputMskType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "msk":
		*e = OutputMskType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutputMskType: %v", v)
	}
}

type OutputMsk struct {
	// Control the number of required acknowledgments.
	Ack *OutputMskAcknowledgments `json:"ack,omitempty"`
	// Amazon Resource Name (ARN) of the role to assume
	AssumeRoleArn *string `json:"assumeRoleArn,omitempty"`
	// External ID to use when assuming role
	AssumeRoleExternalID *string `json:"assumeRoleExternalId,omitempty"`
	// Maximum time to wait for Kafka to respond to an authentication request
	AuthenticationTimeout *int64 `json:"authenticationTimeout,omitempty"`
	// Access key
	AwsAPIKey *string `json:"awsApiKey,omitempty"`
	// AWS authentication method. Choose Auto to use IAM roles.
	AwsAuthenticationMethod OutputMskAuthenticationMethod `json:"awsAuthenticationMethod"`
	// Select (or create) a stored secret that references your access key and secret key.
	AwsSecret *string `json:"awsSecret,omitempty"`
	// Secret key
	AwsSecretKey *string `json:"awsSecretKey,omitempty"`
	// Enter each Kafka broker you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
	Brokers []string `json:"brokers"`
	// Codec to use to compress the data before sending to Kafka
	Compression *OutputMskCompression `json:"compression,omitempty"`
	// Maximum time to wait for a connection to complete successfully
	ConnectionTimeout *int64 `json:"connectionTimeout,omitempty"`
	// Use Assume Role credentials to access MSK
	EnableAssumeRole *bool `json:"enableAssumeRole,omitempty"`
	// MSK cluster service endpoint. If empty, defaults to AWS' Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
	Endpoint *string `json:"endpoint,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// The maximum number of events you want the Destination to allow in a batch before forcing a flush
	FlushEventCount *int64 `json:"flushEventCount,omitempty"`
	// The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent.
	FlushPeriodSec *int64 `json:"flushPeriodSec,omitempty"`
	// Format to use to serialize events before writing to Kafka.
	Format *OutputMskRecordDataFormat `json:"format,omitempty"`
	// Unique ID for this output
	ID                  *string                                     `json:"id,omitempty"`
	KafkaSchemaRegistry *OutputMskKafkaSchemaRegistryAuthentication `json:"kafkaSchemaRegistry,omitempty"`
	// Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting.
	MaxRecordSizeKB *int64 `json:"maxRecordSizeKB,omitempty"`
	// If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data.
	MaxRetries *int64 `json:"maxRetries,omitempty"`
	// Whether to block, drop, or queue events when all receivers are exerting backpressure.
	OnBackpressure *OutputMskBackpressureBehavior `json:"onBackpressure,omitempty"`
	// Pipeline to process data before sending out to this output.
	Pipeline *string `json:"pipeline,omitempty"`
	// Codec to use to compress the persisted data.
	PqCompress *OutputMskCompression1 `json:"pqCompress,omitempty"`
	PqControls *OutputMskPqControls   `json:"pqControls,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	PqMaxFileSize *string `json:"pqMaxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	PqMaxSize *string `json:"pqMaxSize,omitempty"`
	// Whether to block or drop events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged.
	PqOnBackpressure *OutputMskQueueFullBehavior `json:"pqOnBackpressure,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>.
	PqPath *string `json:"pqPath,omitempty"`
	// Toggle this off to forward new events to receiver(s) before queue is flushed. Otherwise, default drain behavior is FIFO (first in, first out).
	PqStrictOrdering *bool `json:"pqStrictOrdering,omitempty"`
	// Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backwards from the moment when credentials are set to expire.
	ReauthenticationThreshold *int64 `json:"reauthenticationThreshold,omitempty"`
	// Region where the MSK cluster is located
	Region OutputMskRegion `json:"region"`
	// Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
	RejectUnauthorized *bool `json:"rejectUnauthorized,omitempty"`
	// Maximum time to wait for Kafka to respond to a request
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`
	// Whether to reuse connections between requests, which can improve performance.
	ReuseConnections *bool `json:"reuseConnections,omitempty"`
	// Signature version to use for signing MSK cluster requests.
	SignatureVersion *OutputMskSignatureVersion `json:"signatureVersion,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Set of fields to automatically add to events using this output. E.g.: cribl_pipe, c*. Wildcards supported.
	SystemFields []string                        `json:"systemFields,omitempty"`
	TLS          *OutputMskTLSSettingsClientSide `json:"tls,omitempty"`
	// The topic to publish events to. Can be overridden using the __topicOut field.
	Topic string         `json:"topic"`
	Type  *OutputMskType `json:"type,omitempty"`
}

func (o *OutputMsk) GetAck() *OutputMskAcknowledgments {
	if o == nil {
		return nil
	}
	return o.Ack
}

func (o *OutputMsk) GetAssumeRoleArn() *string {
	if o == nil {
		return nil
	}
	return o.AssumeRoleArn
}

func (o *OutputMsk) GetAssumeRoleExternalID() *string {
	if o == nil {
		return nil
	}
	return o.AssumeRoleExternalID
}

func (o *OutputMsk) GetAuthenticationTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.AuthenticationTimeout
}

func (o *OutputMsk) GetAwsAPIKey() *string {
	if o == nil {
		return nil
	}
	return o.AwsAPIKey
}

func (o *OutputMsk) GetAwsAuthenticationMethod() OutputMskAuthenticationMethod {
	if o == nil {
		return OutputMskAuthenticationMethod("")
	}
	return o.AwsAuthenticationMethod
}

func (o *OutputMsk) GetAwsSecret() *string {
	if o == nil {
		return nil
	}
	return o.AwsSecret
}

func (o *OutputMsk) GetAwsSecretKey() *string {
	if o == nil {
		return nil
	}
	return o.AwsSecretKey
}

func (o *OutputMsk) GetBrokers() []string {
	if o == nil {
		return []string{}
	}
	return o.Brokers
}

func (o *OutputMsk) GetCompression() *OutputMskCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *OutputMsk) GetConnectionTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.ConnectionTimeout
}

func (o *OutputMsk) GetEnableAssumeRole() *bool {
	if o == nil {
		return nil
	}
	return o.EnableAssumeRole
}

func (o *OutputMsk) GetEndpoint() *string {
	if o == nil {
		return nil
	}
	return o.Endpoint
}

func (o *OutputMsk) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *OutputMsk) GetFlushEventCount() *int64 {
	if o == nil {
		return nil
	}
	return o.FlushEventCount
}

func (o *OutputMsk) GetFlushPeriodSec() *int64 {
	if o == nil {
		return nil
	}
	return o.FlushPeriodSec
}

func (o *OutputMsk) GetFormat() *OutputMskRecordDataFormat {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *OutputMsk) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OutputMsk) GetKafkaSchemaRegistry() *OutputMskKafkaSchemaRegistryAuthentication {
	if o == nil {
		return nil
	}
	return o.KafkaSchemaRegistry
}

func (o *OutputMsk) GetMaxRecordSizeKB() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxRecordSizeKB
}

func (o *OutputMsk) GetMaxRetries() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxRetries
}

func (o *OutputMsk) GetOnBackpressure() *OutputMskBackpressureBehavior {
	if o == nil {
		return nil
	}
	return o.OnBackpressure
}

func (o *OutputMsk) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *OutputMsk) GetPqCompress() *OutputMskCompression1 {
	if o == nil {
		return nil
	}
	return o.PqCompress
}

func (o *OutputMsk) GetPqControls() *OutputMskPqControls {
	if o == nil {
		return nil
	}
	return o.PqControls
}

func (o *OutputMsk) GetPqMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxFileSize
}

func (o *OutputMsk) GetPqMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.PqMaxSize
}

func (o *OutputMsk) GetPqOnBackpressure() *OutputMskQueueFullBehavior {
	if o == nil {
		return nil
	}
	return o.PqOnBackpressure
}

func (o *OutputMsk) GetPqPath() *string {
	if o == nil {
		return nil
	}
	return o.PqPath
}

func (o *OutputMsk) GetPqStrictOrdering() *bool {
	if o == nil {
		return nil
	}
	return o.PqStrictOrdering
}

func (o *OutputMsk) GetReauthenticationThreshold() *int64 {
	if o == nil {
		return nil
	}
	return o.ReauthenticationThreshold
}

func (o *OutputMsk) GetRegion() OutputMskRegion {
	if o == nil {
		return OutputMskRegion("")
	}
	return o.Region
}

func (o *OutputMsk) GetRejectUnauthorized() *bool {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *OutputMsk) GetRequestTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

func (o *OutputMsk) GetReuseConnections() *bool {
	if o == nil {
		return nil
	}
	return o.ReuseConnections
}

func (o *OutputMsk) GetSignatureVersion() *OutputMskSignatureVersion {
	if o == nil {
		return nil
	}
	return o.SignatureVersion
}

func (o *OutputMsk) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *OutputMsk) GetSystemFields() []string {
	if o == nil {
		return nil
	}
	return o.SystemFields
}

func (o *OutputMsk) GetTLS() *OutputMskTLSSettingsClientSide {
	if o == nil {
		return nil
	}
	return o.TLS
}

func (o *OutputMsk) GetTopic() string {
	if o == nil {
		return ""
	}
	return o.Topic
}

func (o *OutputMsk) GetType() *OutputMskType {
	if o == nil {
		return nil
	}
	return o.Type
}
