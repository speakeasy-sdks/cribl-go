// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type EventBreakerRuleTimestampType string

const (
	EventBreakerRuleTimestampTypeAuto    EventBreakerRuleTimestampType = "auto"
	EventBreakerRuleTimestampTypeFormat  EventBreakerRuleTimestampType = "format"
	EventBreakerRuleTimestampTypeCurrent EventBreakerRuleTimestampType = "current"
)

func (e EventBreakerRuleTimestampType) ToPointer() *EventBreakerRuleTimestampType {
	return &e
}

func (e *EventBreakerRuleTimestampType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto":
		fallthrough
	case "format":
		fallthrough
	case "current":
		*e = EventBreakerRuleTimestampType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRuleTimestampType: %v", v)
	}
}

type EventBreakerRuleTimestamp struct {
	Format *string                       `json:"format,omitempty"`
	Length *int64                        `json:"length,omitempty"`
	Type   EventBreakerRuleTimestampType `json:"type"`
}

func (o *EventBreakerRuleTimestamp) GetFormat() *string {
	if o == nil {
		return nil
	}
	return o.Format
}

func (o *EventBreakerRuleTimestamp) GetLength() *int64 {
	if o == nil {
		return nil
	}
	return o.Length
}

func (o *EventBreakerRuleTimestamp) GetType() EventBreakerRuleTimestampType {
	if o == nil {
		return EventBreakerRuleTimestampType("")
	}
	return o.Type
}

type EventBreakerRuleType string

const (
	EventBreakerRuleTypeRegex     EventBreakerRuleType = "regex"
	EventBreakerRuleTypeJSON      EventBreakerRuleType = "json"
	EventBreakerRuleTypeJSONArray EventBreakerRuleType = "json_array"
	EventBreakerRuleTypeHeader    EventBreakerRuleType = "header"
	EventBreakerRuleTypeTimestamp EventBreakerRuleType = "timestamp"
	EventBreakerRuleTypeCsv       EventBreakerRuleType = "csv"
)

func (e EventBreakerRuleType) ToPointer() *EventBreakerRuleType {
	return &e
}

func (e *EventBreakerRuleType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "regex":
		fallthrough
	case "json":
		fallthrough
	case "json_array":
		fallthrough
	case "header":
		fallthrough
	case "timestamp":
		fallthrough
	case "csv":
		*e = EventBreakerRuleType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EventBreakerRuleType: %v", v)
	}
}

type EventBreakerRule struct {
	CleanFields          *bool                     `json:"cleanFields,omitempty"`
	Condition            string                    `json:"condition"`
	Delimiter            *string                   `json:"delimiter,omitempty"`
	DelimiterRegex       *string                   `json:"delimiterRegex,omitempty"`
	Disabled             *bool                     `json:"disabled,omitempty"`
	EscapeChar           *string                   `json:"escapeChar,omitempty"`
	EventBreakerRegex    *string                   `json:"eventBreakerRegex,omitempty"`
	Fields               []EventBreakerRuleFields  `json:"fields,omitempty"`
	FieldsLineRegex      *string                   `json:"fieldsLineRegex,omitempty"`
	HeaderLineRegex      *string                   `json:"headerLineRegex,omitempty"`
	JSONArrayField       *string                   `json:"jsonArrayField,omitempty"`
	JSONExtractAll       *bool                     `json:"jsonExtractAll,omitempty"`
	JSONTimeField        *string                   `json:"jsonTimeField,omitempty"`
	MaxEventBytes        int64                     `json:"maxEventBytes"`
	Name                 string                    `json:"name"`
	NullFieldVal         *string                   `json:"nullFieldVal,omitempty"`
	Parser               interface{}               `json:"parser,omitempty"`
	ParserEnabled        *bool                     `json:"parserEnabled,omitempty"`
	QuoteChar            *string                   `json:"quoteChar,omitempty"`
	TimeField            *string                   `json:"timeField,omitempty"`
	Timestamp            EventBreakerRuleTimestamp `json:"timestamp"`
	TimestampAnchorRegex string                    `json:"timestampAnchorRegex"`
	TimestampEarliest    *string                   `json:"timestampEarliest,omitempty"`
	TimestampLatest      *string                   `json:"timestampLatest,omitempty"`
	TimestampTimezone    string                    `json:"timestampTimezone"`
	Type                 *EventBreakerRuleType     `json:"type,omitempty"`
}

func (o *EventBreakerRule) GetCleanFields() *bool {
	if o == nil {
		return nil
	}
	return o.CleanFields
}

func (o *EventBreakerRule) GetCondition() string {
	if o == nil {
		return ""
	}
	return o.Condition
}

func (o *EventBreakerRule) GetDelimiter() *string {
	if o == nil {
		return nil
	}
	return o.Delimiter
}

func (o *EventBreakerRule) GetDelimiterRegex() *string {
	if o == nil {
		return nil
	}
	return o.DelimiterRegex
}

func (o *EventBreakerRule) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *EventBreakerRule) GetEscapeChar() *string {
	if o == nil {
		return nil
	}
	return o.EscapeChar
}

func (o *EventBreakerRule) GetEventBreakerRegex() *string {
	if o == nil {
		return nil
	}
	return o.EventBreakerRegex
}

func (o *EventBreakerRule) GetFields() []EventBreakerRuleFields {
	if o == nil {
		return nil
	}
	return o.Fields
}

func (o *EventBreakerRule) GetFieldsLineRegex() *string {
	if o == nil {
		return nil
	}
	return o.FieldsLineRegex
}

func (o *EventBreakerRule) GetHeaderLineRegex() *string {
	if o == nil {
		return nil
	}
	return o.HeaderLineRegex
}

func (o *EventBreakerRule) GetJSONArrayField() *string {
	if o == nil {
		return nil
	}
	return o.JSONArrayField
}

func (o *EventBreakerRule) GetJSONExtractAll() *bool {
	if o == nil {
		return nil
	}
	return o.JSONExtractAll
}

func (o *EventBreakerRule) GetJSONTimeField() *string {
	if o == nil {
		return nil
	}
	return o.JSONTimeField
}

func (o *EventBreakerRule) GetMaxEventBytes() int64 {
	if o == nil {
		return 0
	}
	return o.MaxEventBytes
}

func (o *EventBreakerRule) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *EventBreakerRule) GetNullFieldVal() *string {
	if o == nil {
		return nil
	}
	return o.NullFieldVal
}

func (o *EventBreakerRule) GetParser() interface{} {
	if o == nil {
		return nil
	}
	return o.Parser
}

func (o *EventBreakerRule) GetParserEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ParserEnabled
}

func (o *EventBreakerRule) GetQuoteChar() *string {
	if o == nil {
		return nil
	}
	return o.QuoteChar
}

func (o *EventBreakerRule) GetTimeField() *string {
	if o == nil {
		return nil
	}
	return o.TimeField
}

func (o *EventBreakerRule) GetTimestamp() EventBreakerRuleTimestamp {
	if o == nil {
		return EventBreakerRuleTimestamp{}
	}
	return o.Timestamp
}

func (o *EventBreakerRule) GetTimestampAnchorRegex() string {
	if o == nil {
		return ""
	}
	return o.TimestampAnchorRegex
}

func (o *EventBreakerRule) GetTimestampEarliest() *string {
	if o == nil {
		return nil
	}
	return o.TimestampEarliest
}

func (o *EventBreakerRule) GetTimestampLatest() *string {
	if o == nil {
		return nil
	}
	return o.TimestampLatest
}

func (o *EventBreakerRule) GetTimestampTimezone() string {
	if o == nil {
		return ""
	}
	return o.TimestampTimezone
}

func (o *EventBreakerRule) GetType() *EventBreakerRuleType {
	if o == nil {
		return nil
	}
	return o.Type
}
