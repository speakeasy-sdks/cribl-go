// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type Input442Connections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

func (o *Input442Connections) GetOutput() string {
	if o == nil {
		return ""
	}
	return o.Output
}

func (o *Input442Connections) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

type Input442Metadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

func (o *Input442Metadata) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input442Metadata) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input442OptionalFieldsInGeneralSection string

const (
	Input442OptionalFieldsInGeneralSectionUDPPort Input442OptionalFieldsInGeneralSection = "udpPort"
	Input442OptionalFieldsInGeneralSectionTCPPort Input442OptionalFieldsInGeneralSection = "tcpPort"
)

func (e Input442OptionalFieldsInGeneralSection) ToPointer() *Input442OptionalFieldsInGeneralSection {
	return &e
}

func (e *Input442OptionalFieldsInGeneralSection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "udpPort":
		fallthrough
	case "tcpPort":
		*e = Input442OptionalFieldsInGeneralSection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input442OptionalFieldsInGeneralSection: %v", v)
	}
}

// Input442PqCompression - Codec to use to compress the persisted data.
type Input442PqCompression string

const (
	Input442PqCompressionNone Input442PqCompression = "none"
	Input442PqCompressionGzip Input442PqCompression = "gzip"
)

func (e Input442PqCompression) ToPointer() *Input442PqCompression {
	return &e
}

func (e *Input442PqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = Input442PqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input442PqCompression: %v", v)
	}
}

// Input442PqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type Input442PqMode string

const (
	Input442PqModeSmart  Input442PqMode = "smart"
	Input442PqModeAlways Input442PqMode = "always"
)

func (e Input442PqMode) ToPointer() *Input442PqMode {
	return &e
}

func (e *Input442PqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = Input442PqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input442PqMode: %v", v)
	}
}

type Input442Pq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *Input442PqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *Input442PqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

func (o *Input442Pq) GetCommitFrequency() *int64 {
	if o == nil {
		return nil
	}
	return o.CommitFrequency
}

func (o *Input442Pq) GetCompress() *Input442PqCompression {
	if o == nil {
		return nil
	}
	return o.Compress
}

func (o *Input442Pq) GetMaxBufferSize() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxBufferSize
}

func (o *Input442Pq) GetMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxFileSize
}

func (o *Input442Pq) GetMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxSize
}

func (o *Input442Pq) GetMode() *Input442PqMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *Input442Pq) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// Input442TLSSettingsServerSideMaximumTLSVersion - Maximum TLS version to accept from connections.
type Input442TLSSettingsServerSideMaximumTLSVersion string

const (
	Input442TLSSettingsServerSideMaximumTLSVersionTlSv1  Input442TLSSettingsServerSideMaximumTLSVersion = "TLSv1"
	Input442TLSSettingsServerSideMaximumTLSVersionTlSv11 Input442TLSSettingsServerSideMaximumTLSVersion = "TLSv1.1"
	Input442TLSSettingsServerSideMaximumTLSVersionTlSv12 Input442TLSSettingsServerSideMaximumTLSVersion = "TLSv1.2"
	Input442TLSSettingsServerSideMaximumTLSVersionTlSv13 Input442TLSSettingsServerSideMaximumTLSVersion = "TLSv1.3"
)

func (e Input442TLSSettingsServerSideMaximumTLSVersion) ToPointer() *Input442TLSSettingsServerSideMaximumTLSVersion {
	return &e
}

func (e *Input442TLSSettingsServerSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = Input442TLSSettingsServerSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input442TLSSettingsServerSideMaximumTLSVersion: %v", v)
	}
}

// Input442TLSSettingsServerSideMinimumTLSVersion - Minimum TLS version to accept from connections.
type Input442TLSSettingsServerSideMinimumTLSVersion string

const (
	Input442TLSSettingsServerSideMinimumTLSVersionTlSv1  Input442TLSSettingsServerSideMinimumTLSVersion = "TLSv1"
	Input442TLSSettingsServerSideMinimumTLSVersionTlSv11 Input442TLSSettingsServerSideMinimumTLSVersion = "TLSv1.1"
	Input442TLSSettingsServerSideMinimumTLSVersionTlSv12 Input442TLSSettingsServerSideMinimumTLSVersion = "TLSv1.2"
	Input442TLSSettingsServerSideMinimumTLSVersionTlSv13 Input442TLSSettingsServerSideMinimumTLSVersion = "TLSv1.3"
)

func (e Input442TLSSettingsServerSideMinimumTLSVersion) ToPointer() *Input442TLSSettingsServerSideMinimumTLSVersion {
	return &e
}

func (e *Input442TLSSettingsServerSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = Input442TLSSettingsServerSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input442TLSSettingsServerSideMinimumTLSVersion: %v", v)
	}
}

type Input442TLSSettingsServerSide struct {
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string     `json:"certificateName,omitempty"`
	CommonNameRegex interface{} `json:"commonNameRegex,omitempty"`
	Disabled        *bool       `json:"disabled,omitempty"`
	// Maximum TLS version to accept from connections.
	MaxVersion *Input442TLSSettingsServerSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *Input442TLSSettingsServerSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath        *string     `json:"privKeyPath,omitempty"`
	RejectUnauthorized interface{} `json:"rejectUnauthorized,omitempty"`
	// Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
}

func (o *Input442TLSSettingsServerSide) GetCaPath() *string {
	if o == nil {
		return nil
	}
	return o.CaPath
}

func (o *Input442TLSSettingsServerSide) GetCertPath() *string {
	if o == nil {
		return nil
	}
	return o.CertPath
}

func (o *Input442TLSSettingsServerSide) GetCertificateName() *string {
	if o == nil {
		return nil
	}
	return o.CertificateName
}

func (o *Input442TLSSettingsServerSide) GetCommonNameRegex() interface{} {
	if o == nil {
		return nil
	}
	return o.CommonNameRegex
}

func (o *Input442TLSSettingsServerSide) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *Input442TLSSettingsServerSide) GetMaxVersion() *Input442TLSSettingsServerSideMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

func (o *Input442TLSSettingsServerSide) GetMinVersion() *Input442TLSSettingsServerSideMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *Input442TLSSettingsServerSide) GetPassphrase() *string {
	if o == nil {
		return nil
	}
	return o.Passphrase
}

func (o *Input442TLSSettingsServerSide) GetPrivKeyPath() *string {
	if o == nil {
		return nil
	}
	return o.PrivKeyPath
}

func (o *Input442TLSSettingsServerSide) GetRejectUnauthorized() interface{} {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *Input442TLSSettingsServerSide) GetRequestCert() *bool {
	if o == nil {
		return nil
	}
	return o.RequestCert
}

type Input442Type string

const (
	Input442TypeSyslog Input442Type = "syslog"
)

func (e Input442Type) ToPointer() *Input442Type {
	return &e
}

func (e *Input442Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = Input442Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input442Type: %v", v)
	}
}

type Input442 struct {
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []Input442Connections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Wildcard list of fields to keep from source data, * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// Fields to add to events from this input.
	Metadata []Input442Metadata `json:"metadata,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting                  *bool                                   `json:"octetCounting,omitempty"`
	OptionalFieldsInGeneralSection *Input442OptionalFieldsInGeneralSection `json:"optionalFieldsInGeneralSection,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string     `json:"pipeline,omitempty"`
	Pq       *Input442Pq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Whether to treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort int64 `json:"tcpPort"`
	// Timezone to assign to timestamps without timezone info.
	TimestampTimezone *string                        `json:"timestampTimezone,omitempty"`
	TLS               *Input442TLSSettingsServerSide `json:"tls,omitempty"`
	Type              Input442Type                   `json:"type"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort *int64 `json:"udpPort,omitempty"`
}

func (o *Input442) GetAllowNonStandardAppName() *bool {
	if o == nil {
		return nil
	}
	return o.AllowNonStandardAppName
}

func (o *Input442) GetConnections() []Input442Connections {
	if o == nil {
		return nil
	}
	return o.Connections
}

func (o *Input442) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *Input442) GetEnableProxyHeader() *bool {
	if o == nil {
		return nil
	}
	return o.EnableProxyHeader
}

func (o *Input442) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *Input442) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *Input442) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Input442) GetIPWhitelistRegex() *string {
	if o == nil {
		return nil
	}
	return o.IPWhitelistRegex
}

func (o *Input442) GetKeepFieldsList() []string {
	if o == nil {
		return nil
	}
	return o.KeepFieldsList
}

func (o *Input442) GetMaxBufferSize() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxBufferSize
}

func (o *Input442) GetMetadata() []Input442Metadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Input442) GetOctetCounting() *bool {
	if o == nil {
		return nil
	}
	return o.OctetCounting
}

func (o *Input442) GetOptionalFieldsInGeneralSection() *Input442OptionalFieldsInGeneralSection {
	if o == nil {
		return nil
	}
	return o.OptionalFieldsInGeneralSection
}

func (o *Input442) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *Input442) GetPq() *Input442Pq {
	if o == nil {
		return nil
	}
	return o.Pq
}

func (o *Input442) GetPqEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PqEnabled
}

func (o *Input442) GetSendToRoutes() *bool {
	if o == nil {
		return nil
	}
	return o.SendToRoutes
}

func (o *Input442) GetSingleMsgUDPPackets() *bool {
	if o == nil {
		return nil
	}
	return o.SingleMsgUDPPackets
}

func (o *Input442) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *Input442) GetTCPPort() int64 {
	if o == nil {
		return 0
	}
	return o.TCPPort
}

func (o *Input442) GetTimestampTimezone() *string {
	if o == nil {
		return nil
	}
	return o.TimestampTimezone
}

func (o *Input442) GetTLS() *Input442TLSSettingsServerSide {
	if o == nil {
		return nil
	}
	return o.TLS
}

func (o *Input442) GetType() Input442Type {
	if o == nil {
		return Input442Type("")
	}
	return o.Type
}

func (o *Input442) GetUDPPort() *int64 {
	if o == nil {
		return nil
	}
	return o.UDPPort
}

type Input441Connections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

func (o *Input441Connections) GetOutput() string {
	if o == nil {
		return ""
	}
	return o.Output
}

func (o *Input441Connections) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

type Input441Metadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

func (o *Input441Metadata) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input441Metadata) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input441OptionalFieldsInGeneralSection string

const (
	Input441OptionalFieldsInGeneralSectionUDPPort Input441OptionalFieldsInGeneralSection = "udpPort"
	Input441OptionalFieldsInGeneralSectionTCPPort Input441OptionalFieldsInGeneralSection = "tcpPort"
)

func (e Input441OptionalFieldsInGeneralSection) ToPointer() *Input441OptionalFieldsInGeneralSection {
	return &e
}

func (e *Input441OptionalFieldsInGeneralSection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "udpPort":
		fallthrough
	case "tcpPort":
		*e = Input441OptionalFieldsInGeneralSection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input441OptionalFieldsInGeneralSection: %v", v)
	}
}

// Input441PqCompression - Codec to use to compress the persisted data.
type Input441PqCompression string

const (
	Input441PqCompressionNone Input441PqCompression = "none"
	Input441PqCompressionGzip Input441PqCompression = "gzip"
)

func (e Input441PqCompression) ToPointer() *Input441PqCompression {
	return &e
}

func (e *Input441PqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = Input441PqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input441PqCompression: %v", v)
	}
}

// Input441PqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type Input441PqMode string

const (
	Input441PqModeSmart  Input441PqMode = "smart"
	Input441PqModeAlways Input441PqMode = "always"
)

func (e Input441PqMode) ToPointer() *Input441PqMode {
	return &e
}

func (e *Input441PqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = Input441PqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input441PqMode: %v", v)
	}
}

type Input441Pq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *Input441PqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *Input441PqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

func (o *Input441Pq) GetCommitFrequency() *int64 {
	if o == nil {
		return nil
	}
	return o.CommitFrequency
}

func (o *Input441Pq) GetCompress() *Input441PqCompression {
	if o == nil {
		return nil
	}
	return o.Compress
}

func (o *Input441Pq) GetMaxBufferSize() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxBufferSize
}

func (o *Input441Pq) GetMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxFileSize
}

func (o *Input441Pq) GetMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxSize
}

func (o *Input441Pq) GetMode() *Input441PqMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *Input441Pq) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// Input441TLSSettingsServerSideMaximumTLSVersion - Maximum TLS version to accept from connections.
type Input441TLSSettingsServerSideMaximumTLSVersion string

const (
	Input441TLSSettingsServerSideMaximumTLSVersionTlSv1  Input441TLSSettingsServerSideMaximumTLSVersion = "TLSv1"
	Input441TLSSettingsServerSideMaximumTLSVersionTlSv11 Input441TLSSettingsServerSideMaximumTLSVersion = "TLSv1.1"
	Input441TLSSettingsServerSideMaximumTLSVersionTlSv12 Input441TLSSettingsServerSideMaximumTLSVersion = "TLSv1.2"
	Input441TLSSettingsServerSideMaximumTLSVersionTlSv13 Input441TLSSettingsServerSideMaximumTLSVersion = "TLSv1.3"
)

func (e Input441TLSSettingsServerSideMaximumTLSVersion) ToPointer() *Input441TLSSettingsServerSideMaximumTLSVersion {
	return &e
}

func (e *Input441TLSSettingsServerSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = Input441TLSSettingsServerSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input441TLSSettingsServerSideMaximumTLSVersion: %v", v)
	}
}

// Input441TLSSettingsServerSideMinimumTLSVersion - Minimum TLS version to accept from connections.
type Input441TLSSettingsServerSideMinimumTLSVersion string

const (
	Input441TLSSettingsServerSideMinimumTLSVersionTlSv1  Input441TLSSettingsServerSideMinimumTLSVersion = "TLSv1"
	Input441TLSSettingsServerSideMinimumTLSVersionTlSv11 Input441TLSSettingsServerSideMinimumTLSVersion = "TLSv1.1"
	Input441TLSSettingsServerSideMinimumTLSVersionTlSv12 Input441TLSSettingsServerSideMinimumTLSVersion = "TLSv1.2"
	Input441TLSSettingsServerSideMinimumTLSVersionTlSv13 Input441TLSSettingsServerSideMinimumTLSVersion = "TLSv1.3"
)

func (e Input441TLSSettingsServerSideMinimumTLSVersion) ToPointer() *Input441TLSSettingsServerSideMinimumTLSVersion {
	return &e
}

func (e *Input441TLSSettingsServerSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = Input441TLSSettingsServerSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input441TLSSettingsServerSideMinimumTLSVersion: %v", v)
	}
}

type Input441TLSSettingsServerSide struct {
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string     `json:"certificateName,omitempty"`
	CommonNameRegex interface{} `json:"commonNameRegex,omitempty"`
	Disabled        *bool       `json:"disabled,omitempty"`
	// Maximum TLS version to accept from connections.
	MaxVersion *Input441TLSSettingsServerSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *Input441TLSSettingsServerSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath        *string     `json:"privKeyPath,omitempty"`
	RejectUnauthorized interface{} `json:"rejectUnauthorized,omitempty"`
	// Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
}

func (o *Input441TLSSettingsServerSide) GetCaPath() *string {
	if o == nil {
		return nil
	}
	return o.CaPath
}

func (o *Input441TLSSettingsServerSide) GetCertPath() *string {
	if o == nil {
		return nil
	}
	return o.CertPath
}

func (o *Input441TLSSettingsServerSide) GetCertificateName() *string {
	if o == nil {
		return nil
	}
	return o.CertificateName
}

func (o *Input441TLSSettingsServerSide) GetCommonNameRegex() interface{} {
	if o == nil {
		return nil
	}
	return o.CommonNameRegex
}

func (o *Input441TLSSettingsServerSide) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *Input441TLSSettingsServerSide) GetMaxVersion() *Input441TLSSettingsServerSideMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

func (o *Input441TLSSettingsServerSide) GetMinVersion() *Input441TLSSettingsServerSideMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *Input441TLSSettingsServerSide) GetPassphrase() *string {
	if o == nil {
		return nil
	}
	return o.Passphrase
}

func (o *Input441TLSSettingsServerSide) GetPrivKeyPath() *string {
	if o == nil {
		return nil
	}
	return o.PrivKeyPath
}

func (o *Input441TLSSettingsServerSide) GetRejectUnauthorized() interface{} {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *Input441TLSSettingsServerSide) GetRequestCert() *bool {
	if o == nil {
		return nil
	}
	return o.RequestCert
}

type Input441Type string

const (
	Input441TypeSyslog Input441Type = "syslog"
)

func (e Input441Type) ToPointer() *Input441Type {
	return &e
}

func (e *Input441Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "syslog":
		*e = Input441Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input441Type: %v", v)
	}
}

type Input441 struct {
	// Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
	AllowNonStandardAppName *bool `json:"allowNonStandardAppName,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []Input441Connections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// Regex matching IP addresses that are allowed to send data
	IPWhitelistRegex *string `json:"ipWhitelistRegex,omitempty"`
	// Wildcard list of fields to keep from source data, * = ALL (default)
	KeepFieldsList []string `json:"keepFieldsList,omitempty"`
	// Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// Fields to add to events from this input.
	Metadata []Input441Metadata `json:"metadata,omitempty"`
	// Enable if incoming messages use octet counting per RFC 6587.
	OctetCounting                  *bool                                   `json:"octetCounting,omitempty"`
	OptionalFieldsInGeneralSection *Input441OptionalFieldsInGeneralSection `json:"optionalFieldsInGeneralSection,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string     `json:"pipeline,omitempty"`
	Pq       *Input441Pq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// Whether to treat UDP packet data received as full syslog message
	SingleMsgUDPPackets *bool `json:"singleMsgUdpPackets,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string `json:"streamtags,omitempty"`
	// Enter TCP port number to listen on. Not required if listening on UDP.
	TCPPort *int64 `json:"tcpPort,omitempty"`
	// Timezone to assign to timestamps without timezone info.
	TimestampTimezone *string                        `json:"timestampTimezone,omitempty"`
	TLS               *Input441TLSSettingsServerSide `json:"tls,omitempty"`
	Type              Input441Type                   `json:"type"`
	// Enter UDP port number to listen on. Not required if listening on TCP.
	UDPPort int64 `json:"udpPort"`
}

func (o *Input441) GetAllowNonStandardAppName() *bool {
	if o == nil {
		return nil
	}
	return o.AllowNonStandardAppName
}

func (o *Input441) GetConnections() []Input441Connections {
	if o == nil {
		return nil
	}
	return o.Connections
}

func (o *Input441) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *Input441) GetEnableProxyHeader() *bool {
	if o == nil {
		return nil
	}
	return o.EnableProxyHeader
}

func (o *Input441) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *Input441) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *Input441) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Input441) GetIPWhitelistRegex() *string {
	if o == nil {
		return nil
	}
	return o.IPWhitelistRegex
}

func (o *Input441) GetKeepFieldsList() []string {
	if o == nil {
		return nil
	}
	return o.KeepFieldsList
}

func (o *Input441) GetMaxBufferSize() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxBufferSize
}

func (o *Input441) GetMetadata() []Input441Metadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Input441) GetOctetCounting() *bool {
	if o == nil {
		return nil
	}
	return o.OctetCounting
}

func (o *Input441) GetOptionalFieldsInGeneralSection() *Input441OptionalFieldsInGeneralSection {
	if o == nil {
		return nil
	}
	return o.OptionalFieldsInGeneralSection
}

func (o *Input441) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *Input441) GetPq() *Input441Pq {
	if o == nil {
		return nil
	}
	return o.Pq
}

func (o *Input441) GetPqEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PqEnabled
}

func (o *Input441) GetSendToRoutes() *bool {
	if o == nil {
		return nil
	}
	return o.SendToRoutes
}

func (o *Input441) GetSingleMsgUDPPackets() *bool {
	if o == nil {
		return nil
	}
	return o.SingleMsgUDPPackets
}

func (o *Input441) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *Input441) GetTCPPort() *int64 {
	if o == nil {
		return nil
	}
	return o.TCPPort
}

func (o *Input441) GetTimestampTimezone() *string {
	if o == nil {
		return nil
	}
	return o.TimestampTimezone
}

func (o *Input441) GetTLS() *Input441TLSSettingsServerSide {
	if o == nil {
		return nil
	}
	return o.TLS
}

func (o *Input441) GetType() Input441Type {
	if o == nil {
		return Input441Type("")
	}
	return o.Type
}

func (o *Input441) GetUDPPort() int64 {
	if o == nil {
		return 0
	}
	return o.UDPPort
}

type Input112Connections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

func (o *Input112Connections) GetOutput() string {
	if o == nil {
		return ""
	}
	return o.Output
}

func (o *Input112Connections) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

// Input112LokiAuthAuthenticationType - Loki logs authentication type
type Input112LokiAuthAuthenticationType string

const (
	Input112LokiAuthAuthenticationTypeOauth             Input112LokiAuthAuthenticationType = "oauth"
	Input112LokiAuthAuthenticationTypeBasic             Input112LokiAuthAuthenticationType = "basic"
	Input112LokiAuthAuthenticationTypeCredentialsSecret Input112LokiAuthAuthenticationType = "credentialsSecret"
	Input112LokiAuthAuthenticationTypeToken             Input112LokiAuthAuthenticationType = "token"
	Input112LokiAuthAuthenticationTypeTextSecret        Input112LokiAuthAuthenticationType = "textSecret"
)

func (e Input112LokiAuthAuthenticationType) ToPointer() *Input112LokiAuthAuthenticationType {
	return &e
}

func (e *Input112LokiAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth":
		fallthrough
	case "basic":
		fallthrough
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		*e = Input112LokiAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input112LokiAuthAuthenticationType: %v", v)
	}
}

type Input112LokiAuthOauthHeaders struct {
	// OAuth header name
	Name string `json:"name"`
	// OAuth header value
	Value string `json:"value"`
}

func (o *Input112LokiAuthOauthHeaders) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input112LokiAuthOauthHeaders) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input112LokiAuthOauthParams struct {
	// OAuth parameter name
	Name string `json:"name"`
	// OAuth parameter value
	Value string `json:"value"`
}

func (o *Input112LokiAuthOauthParams) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input112LokiAuthOauthParams) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input112LokiAuth struct {
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`
	// Loki logs authentication type
	AuthType *Input112LokiAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Input112LokiAuthOauthHeaders `json:"oauthHeaders,omitempty"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Input112LokiAuthOauthParams `json:"oauthParams,omitempty"`
	// Password for Basic authentication
	Password *string `json:"password,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *int64 `json:"tokenTimeoutSecs,omitempty"`
	// Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

func (o *Input112LokiAuth) GetAuthHeaderExpr() *string {
	if o == nil {
		return nil
	}
	return o.AuthHeaderExpr
}

func (o *Input112LokiAuth) GetAuthType() *Input112LokiAuthAuthenticationType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Input112LokiAuth) GetCredentialsSecret() *string {
	if o == nil {
		return nil
	}
	return o.CredentialsSecret
}

func (o *Input112LokiAuth) GetLoginURL() *string {
	if o == nil {
		return nil
	}
	return o.LoginURL
}

func (o *Input112LokiAuth) GetOauthHeaders() []Input112LokiAuthOauthHeaders {
	if o == nil {
		return nil
	}
	return o.OauthHeaders
}

func (o *Input112LokiAuth) GetOauthParams() []Input112LokiAuthOauthParams {
	if o == nil {
		return nil
	}
	return o.OauthParams
}

func (o *Input112LokiAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *Input112LokiAuth) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

func (o *Input112LokiAuth) GetSecretParamName() *string {
	if o == nil {
		return nil
	}
	return o.SecretParamName
}

func (o *Input112LokiAuth) GetSpacer() *string {
	if o == nil {
		return nil
	}
	return o.Spacer
}

func (o *Input112LokiAuth) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

func (o *Input112LokiAuth) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

func (o *Input112LokiAuth) GetTokenAttributeName() *string {
	if o == nil {
		return nil
	}
	return o.TokenAttributeName
}

func (o *Input112LokiAuth) GetTokenTimeoutSecs() *int64 {
	if o == nil {
		return nil
	}
	return o.TokenTimeoutSecs
}

func (o *Input112LokiAuth) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

type Input112Metadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

func (o *Input112Metadata) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input112Metadata) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// Input112PqCompression - Codec to use to compress the persisted data.
type Input112PqCompression string

const (
	Input112PqCompressionNone Input112PqCompression = "none"
	Input112PqCompressionGzip Input112PqCompression = "gzip"
)

func (e Input112PqCompression) ToPointer() *Input112PqCompression {
	return &e
}

func (e *Input112PqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = Input112PqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input112PqCompression: %v", v)
	}
}

// Input112PqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type Input112PqMode string

const (
	Input112PqModeSmart  Input112PqMode = "smart"
	Input112PqModeAlways Input112PqMode = "always"
)

func (e Input112PqMode) ToPointer() *Input112PqMode {
	return &e
}

func (e *Input112PqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = Input112PqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input112PqMode: %v", v)
	}
}

type Input112Pq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *Input112PqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *Input112PqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

func (o *Input112Pq) GetCommitFrequency() *int64 {
	if o == nil {
		return nil
	}
	return o.CommitFrequency
}

func (o *Input112Pq) GetCompress() *Input112PqCompression {
	if o == nil {
		return nil
	}
	return o.Compress
}

func (o *Input112Pq) GetMaxBufferSize() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxBufferSize
}

func (o *Input112Pq) GetMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxFileSize
}

func (o *Input112Pq) GetMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxSize
}

func (o *Input112Pq) GetMode() *Input112PqMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *Input112Pq) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// Input112PrometheusAuthAuthenticationType - Remote Write authentication type
type Input112PrometheusAuthAuthenticationType string

const (
	Input112PrometheusAuthAuthenticationTypeOauth             Input112PrometheusAuthAuthenticationType = "oauth"
	Input112PrometheusAuthAuthenticationTypeBasic             Input112PrometheusAuthAuthenticationType = "basic"
	Input112PrometheusAuthAuthenticationTypeCredentialsSecret Input112PrometheusAuthAuthenticationType = "credentialsSecret"
	Input112PrometheusAuthAuthenticationTypeToken             Input112PrometheusAuthAuthenticationType = "token"
	Input112PrometheusAuthAuthenticationTypeTextSecret        Input112PrometheusAuthAuthenticationType = "textSecret"
)

func (e Input112PrometheusAuthAuthenticationType) ToPointer() *Input112PrometheusAuthAuthenticationType {
	return &e
}

func (e *Input112PrometheusAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth":
		fallthrough
	case "basic":
		fallthrough
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		*e = Input112PrometheusAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input112PrometheusAuthAuthenticationType: %v", v)
	}
}

type Input112PrometheusAuthOauthHeaders struct {
	// OAuth header name
	Name string `json:"name"`
	// OAuth header value
	Value string `json:"value"`
}

func (o *Input112PrometheusAuthOauthHeaders) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input112PrometheusAuthOauthHeaders) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input112PrometheusAuthOauthParams struct {
	// OAuth parameter name
	Name string `json:"name"`
	// OAuth parameter value
	Value string `json:"value"`
}

func (o *Input112PrometheusAuthOauthParams) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input112PrometheusAuthOauthParams) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input112PrometheusAuth struct {
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`
	// Remote Write authentication type
	AuthType *Input112PrometheusAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Input112PrometheusAuthOauthHeaders `json:"oauthHeaders,omitempty"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Input112PrometheusAuthOauthParams `json:"oauthParams,omitempty"`
	// Password for Basic authentication
	Password *string `json:"password,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *int64 `json:"tokenTimeoutSecs,omitempty"`
	// Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

func (o *Input112PrometheusAuth) GetAuthHeaderExpr() *string {
	if o == nil {
		return nil
	}
	return o.AuthHeaderExpr
}

func (o *Input112PrometheusAuth) GetAuthType() *Input112PrometheusAuthAuthenticationType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Input112PrometheusAuth) GetCredentialsSecret() *string {
	if o == nil {
		return nil
	}
	return o.CredentialsSecret
}

func (o *Input112PrometheusAuth) GetLoginURL() *string {
	if o == nil {
		return nil
	}
	return o.LoginURL
}

func (o *Input112PrometheusAuth) GetOauthHeaders() []Input112PrometheusAuthOauthHeaders {
	if o == nil {
		return nil
	}
	return o.OauthHeaders
}

func (o *Input112PrometheusAuth) GetOauthParams() []Input112PrometheusAuthOauthParams {
	if o == nil {
		return nil
	}
	return o.OauthParams
}

func (o *Input112PrometheusAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *Input112PrometheusAuth) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

func (o *Input112PrometheusAuth) GetSecretParamName() *string {
	if o == nil {
		return nil
	}
	return o.SecretParamName
}

func (o *Input112PrometheusAuth) GetSpacer() *string {
	if o == nil {
		return nil
	}
	return o.Spacer
}

func (o *Input112PrometheusAuth) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

func (o *Input112PrometheusAuth) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

func (o *Input112PrometheusAuth) GetTokenAttributeName() *string {
	if o == nil {
		return nil
	}
	return o.TokenAttributeName
}

func (o *Input112PrometheusAuth) GetTokenTimeoutSecs() *int64 {
	if o == nil {
		return nil
	}
	return o.TokenTimeoutSecs
}

func (o *Input112PrometheusAuth) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

// Input112TLSSettingsServerSideMaximumTLSVersion - Maximum TLS version to accept from connections.
type Input112TLSSettingsServerSideMaximumTLSVersion string

const (
	Input112TLSSettingsServerSideMaximumTLSVersionTlSv1  Input112TLSSettingsServerSideMaximumTLSVersion = "TLSv1"
	Input112TLSSettingsServerSideMaximumTLSVersionTlSv11 Input112TLSSettingsServerSideMaximumTLSVersion = "TLSv1.1"
	Input112TLSSettingsServerSideMaximumTLSVersionTlSv12 Input112TLSSettingsServerSideMaximumTLSVersion = "TLSv1.2"
	Input112TLSSettingsServerSideMaximumTLSVersionTlSv13 Input112TLSSettingsServerSideMaximumTLSVersion = "TLSv1.3"
)

func (e Input112TLSSettingsServerSideMaximumTLSVersion) ToPointer() *Input112TLSSettingsServerSideMaximumTLSVersion {
	return &e
}

func (e *Input112TLSSettingsServerSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = Input112TLSSettingsServerSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input112TLSSettingsServerSideMaximumTLSVersion: %v", v)
	}
}

// Input112TLSSettingsServerSideMinimumTLSVersion - Minimum TLS version to accept from connections.
type Input112TLSSettingsServerSideMinimumTLSVersion string

const (
	Input112TLSSettingsServerSideMinimumTLSVersionTlSv1  Input112TLSSettingsServerSideMinimumTLSVersion = "TLSv1"
	Input112TLSSettingsServerSideMinimumTLSVersionTlSv11 Input112TLSSettingsServerSideMinimumTLSVersion = "TLSv1.1"
	Input112TLSSettingsServerSideMinimumTLSVersionTlSv12 Input112TLSSettingsServerSideMinimumTLSVersion = "TLSv1.2"
	Input112TLSSettingsServerSideMinimumTLSVersionTlSv13 Input112TLSSettingsServerSideMinimumTLSVersion = "TLSv1.3"
)

func (e Input112TLSSettingsServerSideMinimumTLSVersion) ToPointer() *Input112TLSSettingsServerSideMinimumTLSVersion {
	return &e
}

func (e *Input112TLSSettingsServerSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = Input112TLSSettingsServerSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input112TLSSettingsServerSideMinimumTLSVersion: %v", v)
	}
}

type Input112TLSSettingsServerSide struct {
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string     `json:"certificateName,omitempty"`
	CommonNameRegex interface{} `json:"commonNameRegex,omitempty"`
	Disabled        *bool       `json:"disabled,omitempty"`
	// Maximum TLS version to accept from connections.
	MaxVersion *Input112TLSSettingsServerSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *Input112TLSSettingsServerSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath        *string     `json:"privKeyPath,omitempty"`
	RejectUnauthorized interface{} `json:"rejectUnauthorized,omitempty"`
	// Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
}

func (o *Input112TLSSettingsServerSide) GetCaPath() *string {
	if o == nil {
		return nil
	}
	return o.CaPath
}

func (o *Input112TLSSettingsServerSide) GetCertPath() *string {
	if o == nil {
		return nil
	}
	return o.CertPath
}

func (o *Input112TLSSettingsServerSide) GetCertificateName() *string {
	if o == nil {
		return nil
	}
	return o.CertificateName
}

func (o *Input112TLSSettingsServerSide) GetCommonNameRegex() interface{} {
	if o == nil {
		return nil
	}
	return o.CommonNameRegex
}

func (o *Input112TLSSettingsServerSide) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *Input112TLSSettingsServerSide) GetMaxVersion() *Input112TLSSettingsServerSideMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

func (o *Input112TLSSettingsServerSide) GetMinVersion() *Input112TLSSettingsServerSideMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *Input112TLSSettingsServerSide) GetPassphrase() *string {
	if o == nil {
		return nil
	}
	return o.Passphrase
}

func (o *Input112TLSSettingsServerSide) GetPrivKeyPath() *string {
	if o == nil {
		return nil
	}
	return o.PrivKeyPath
}

func (o *Input112TLSSettingsServerSide) GetRejectUnauthorized() interface{} {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *Input112TLSSettingsServerSide) GetRequestCert() *bool {
	if o == nil {
		return nil
	}
	return o.RequestCert
}

type Input112Type string

const (
	Input112TypeGrafana Input112Type = "grafana"
)

func (e Input112Type) ToPointer() *Input112Type {
	return &e
}

func (e *Input112Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = Input112Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input112Type: %v", v)
	}
}

type Input112 struct {
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *int64 `json:"activityLogSampleRate,omitempty"`
	// Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []Input112Connections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *int64 `json:"keepAliveTimeout,omitempty"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI  string            `json:"lokiAPI"`
	LokiAuth *Input112LokiAuth `json:"lokiAuth,omitempty"`
	// Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *int64 `json:"maxActiveReq,omitempty"`
	// Fields to add to events from this input.
	Metadata []Input112Metadata `json:"metadata,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string `json:"pipeline,omitempty"`
	// Port to listen on.
	Port int64       `json:"port"`
	Pq   *Input112Pq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: http://<your‑upstream‑URL>:<your‑port>/api/prom/push.
	PrometheusAPI  *string                 `json:"prometheusAPI,omitempty"`
	PrometheusAuth *Input112PrometheusAuth `json:"prometheusAuth,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *int64 `json:"socketTimeout,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string                       `json:"streamtags,omitempty"`
	TLS        *Input112TLSSettingsServerSide `json:"tls,omitempty"`
	Type       *Input112Type                  `json:"type,omitempty"`
}

func (o *Input112) GetActivityLogSampleRate() *int64 {
	if o == nil {
		return nil
	}
	return o.ActivityLogSampleRate
}

func (o *Input112) GetCaptureHeaders() *bool {
	if o == nil {
		return nil
	}
	return o.CaptureHeaders
}

func (o *Input112) GetConnections() []Input112Connections {
	if o == nil {
		return nil
	}
	return o.Connections
}

func (o *Input112) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *Input112) GetEnableProxyHeader() *bool {
	if o == nil {
		return nil
	}
	return o.EnableProxyHeader
}

func (o *Input112) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *Input112) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *Input112) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Input112) GetKeepAliveTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.KeepAliveTimeout
}

func (o *Input112) GetLokiAPI() string {
	if o == nil {
		return ""
	}
	return o.LokiAPI
}

func (o *Input112) GetLokiAuth() *Input112LokiAuth {
	if o == nil {
		return nil
	}
	return o.LokiAuth
}

func (o *Input112) GetMaxActiveReq() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxActiveReq
}

func (o *Input112) GetMetadata() []Input112Metadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Input112) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *Input112) GetPort() int64 {
	if o == nil {
		return 0
	}
	return o.Port
}

func (o *Input112) GetPq() *Input112Pq {
	if o == nil {
		return nil
	}
	return o.Pq
}

func (o *Input112) GetPqEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PqEnabled
}

func (o *Input112) GetPrometheusAPI() *string {
	if o == nil {
		return nil
	}
	return o.PrometheusAPI
}

func (o *Input112) GetPrometheusAuth() *Input112PrometheusAuth {
	if o == nil {
		return nil
	}
	return o.PrometheusAuth
}

func (o *Input112) GetRequestTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

func (o *Input112) GetSendToRoutes() *bool {
	if o == nil {
		return nil
	}
	return o.SendToRoutes
}

func (o *Input112) GetSocketTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.SocketTimeout
}

func (o *Input112) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *Input112) GetTLS() *Input112TLSSettingsServerSide {
	if o == nil {
		return nil
	}
	return o.TLS
}

func (o *Input112) GetType() *Input112Type {
	if o == nil {
		return nil
	}
	return o.Type
}

type Input111Connections struct {
	// Select a Destination.
	Output string `json:"output"`
	// Select Pipeline or Pack. Optional.
	Pipeline *string `json:"pipeline,omitempty"`
}

func (o *Input111Connections) GetOutput() string {
	if o == nil {
		return ""
	}
	return o.Output
}

func (o *Input111Connections) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

// Input111LokiAuthAuthenticationType - Loki logs authentication type
type Input111LokiAuthAuthenticationType string

const (
	Input111LokiAuthAuthenticationTypeOauth             Input111LokiAuthAuthenticationType = "oauth"
	Input111LokiAuthAuthenticationTypeBasic             Input111LokiAuthAuthenticationType = "basic"
	Input111LokiAuthAuthenticationTypeCredentialsSecret Input111LokiAuthAuthenticationType = "credentialsSecret"
	Input111LokiAuthAuthenticationTypeToken             Input111LokiAuthAuthenticationType = "token"
	Input111LokiAuthAuthenticationTypeTextSecret        Input111LokiAuthAuthenticationType = "textSecret"
)

func (e Input111LokiAuthAuthenticationType) ToPointer() *Input111LokiAuthAuthenticationType {
	return &e
}

func (e *Input111LokiAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth":
		fallthrough
	case "basic":
		fallthrough
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		*e = Input111LokiAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input111LokiAuthAuthenticationType: %v", v)
	}
}

type Input111LokiAuthOauthHeaders struct {
	// OAuth header name
	Name string `json:"name"`
	// OAuth header value
	Value string `json:"value"`
}

func (o *Input111LokiAuthOauthHeaders) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input111LokiAuthOauthHeaders) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input111LokiAuthOauthParams struct {
	// OAuth parameter name
	Name string `json:"name"`
	// OAuth parameter value
	Value string `json:"value"`
}

func (o *Input111LokiAuthOauthParams) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input111LokiAuthOauthParams) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input111LokiAuth struct {
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`
	// Loki logs authentication type
	AuthType *Input111LokiAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Input111LokiAuthOauthHeaders `json:"oauthHeaders,omitempty"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Input111LokiAuthOauthParams `json:"oauthParams,omitempty"`
	// Password for Basic authentication
	Password *string `json:"password,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *int64 `json:"tokenTimeoutSecs,omitempty"`
	// Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

func (o *Input111LokiAuth) GetAuthHeaderExpr() *string {
	if o == nil {
		return nil
	}
	return o.AuthHeaderExpr
}

func (o *Input111LokiAuth) GetAuthType() *Input111LokiAuthAuthenticationType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Input111LokiAuth) GetCredentialsSecret() *string {
	if o == nil {
		return nil
	}
	return o.CredentialsSecret
}

func (o *Input111LokiAuth) GetLoginURL() *string {
	if o == nil {
		return nil
	}
	return o.LoginURL
}

func (o *Input111LokiAuth) GetOauthHeaders() []Input111LokiAuthOauthHeaders {
	if o == nil {
		return nil
	}
	return o.OauthHeaders
}

func (o *Input111LokiAuth) GetOauthParams() []Input111LokiAuthOauthParams {
	if o == nil {
		return nil
	}
	return o.OauthParams
}

func (o *Input111LokiAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *Input111LokiAuth) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

func (o *Input111LokiAuth) GetSecretParamName() *string {
	if o == nil {
		return nil
	}
	return o.SecretParamName
}

func (o *Input111LokiAuth) GetSpacer() *string {
	if o == nil {
		return nil
	}
	return o.Spacer
}

func (o *Input111LokiAuth) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

func (o *Input111LokiAuth) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

func (o *Input111LokiAuth) GetTokenAttributeName() *string {
	if o == nil {
		return nil
	}
	return o.TokenAttributeName
}

func (o *Input111LokiAuth) GetTokenTimeoutSecs() *int64 {
	if o == nil {
		return nil
	}
	return o.TokenTimeoutSecs
}

func (o *Input111LokiAuth) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

type Input111Metadata struct {
	// Field name
	Name string `json:"name"`
	// JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
	Value string `json:"value"`
}

func (o *Input111Metadata) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input111Metadata) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

// Input111PqCompression - Codec to use to compress the persisted data.
type Input111PqCompression string

const (
	Input111PqCompressionNone Input111PqCompression = "none"
	Input111PqCompressionGzip Input111PqCompression = "gzip"
)

func (e Input111PqCompression) ToPointer() *Input111PqCompression {
	return &e
}

func (e *Input111PqCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "gzip":
		*e = Input111PqCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input111PqCompression: %v", v)
	}
}

// Input111PqMode - With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
type Input111PqMode string

const (
	Input111PqModeSmart  Input111PqMode = "smart"
	Input111PqModeAlways Input111PqMode = "always"
)

func (e Input111PqMode) ToPointer() *Input111PqMode {
	return &e
}

func (e *Input111PqMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "smart":
		fallthrough
	case "always":
		*e = Input111PqMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input111PqMode: %v", v)
	}
}

type Input111Pq struct {
	// The number of events to send downstream before committing that Stream has read them.
	CommitFrequency *int64 `json:"commitFrequency,omitempty"`
	// Codec to use to compress the persisted data.
	Compress *Input111PqCompression `json:"compress,omitempty"`
	// The maximum number of events to hold in memory before writing the events to disk.
	MaxBufferSize *int64 `json:"maxBufferSize,omitempty"`
	// The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.).
	MaxFileSize *string `json:"maxFileSize,omitempty"`
	// The maximum amount of disk space the queue is allowed to consume. Once reached, the system stops queueing and applies the fallback Queue-full behavior. Enter a numeral with units of KB, MB, etc.
	MaxSize *string `json:"maxSize,omitempty"`
	// With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
	Mode *Input111PqMode `json:"mode,omitempty"`
	// The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>.
	Path *string `json:"path,omitempty"`
}

func (o *Input111Pq) GetCommitFrequency() *int64 {
	if o == nil {
		return nil
	}
	return o.CommitFrequency
}

func (o *Input111Pq) GetCompress() *Input111PqCompression {
	if o == nil {
		return nil
	}
	return o.Compress
}

func (o *Input111Pq) GetMaxBufferSize() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxBufferSize
}

func (o *Input111Pq) GetMaxFileSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxFileSize
}

func (o *Input111Pq) GetMaxSize() *string {
	if o == nil {
		return nil
	}
	return o.MaxSize
}

func (o *Input111Pq) GetMode() *Input111PqMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *Input111Pq) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

// Input111PrometheusAuthAuthenticationType - Remote Write authentication type
type Input111PrometheusAuthAuthenticationType string

const (
	Input111PrometheusAuthAuthenticationTypeOauth             Input111PrometheusAuthAuthenticationType = "oauth"
	Input111PrometheusAuthAuthenticationTypeBasic             Input111PrometheusAuthAuthenticationType = "basic"
	Input111PrometheusAuthAuthenticationTypeCredentialsSecret Input111PrometheusAuthAuthenticationType = "credentialsSecret"
	Input111PrometheusAuthAuthenticationTypeToken             Input111PrometheusAuthAuthenticationType = "token"
	Input111PrometheusAuthAuthenticationTypeTextSecret        Input111PrometheusAuthAuthenticationType = "textSecret"
)

func (e Input111PrometheusAuthAuthenticationType) ToPointer() *Input111PrometheusAuthAuthenticationType {
	return &e
}

func (e *Input111PrometheusAuthAuthenticationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth":
		fallthrough
	case "basic":
		fallthrough
	case "credentialsSecret":
		fallthrough
	case "token":
		fallthrough
	case "textSecret":
		*e = Input111PrometheusAuthAuthenticationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input111PrometheusAuthAuthenticationType: %v", v)
	}
}

type Input111PrometheusAuthOauthHeaders struct {
	// OAuth header name
	Name string `json:"name"`
	// OAuth header value
	Value string `json:"value"`
}

func (o *Input111PrometheusAuthOauthHeaders) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input111PrometheusAuthOauthHeaders) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input111PrometheusAuthOauthParams struct {
	// OAuth parameter name
	Name string `json:"name"`
	// OAuth parameter value
	Value string `json:"value"`
}

func (o *Input111PrometheusAuthOauthParams) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Input111PrometheusAuthOauthParams) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Input111PrometheusAuth struct {
	// JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
	AuthHeaderExpr *string `json:"authHeaderExpr,omitempty"`
	// Remote Write authentication type
	AuthType *Input111PrometheusAuthAuthenticationType `json:"authType,omitempty"`
	// Select (or create) a secret that references your credentials
	CredentialsSecret *string `json:"credentialsSecret,omitempty"`
	// URL for OAuth
	LoginURL *string `json:"loginUrl,omitempty"`
	// Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthHeaders []Input111PrometheusAuthOauthHeaders `json:"oauthHeaders,omitempty"`
	// Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
	OauthParams []Input111PrometheusAuthOauthParams `json:"oauthParams,omitempty"`
	// Password for Basic authentication
	Password *string `json:"password,omitempty"`
	// Secret parameter value to pass in request body
	Secret *string `json:"secret,omitempty"`
	// Secret parameter name to pass in request body
	SecretParamName *string `json:"secretParamName,omitempty"`
	Spacer          *string `json:"spacer,omitempty"`
	// Select (or create) a stored text secret
	TextSecret *string `json:"textSecret,omitempty"`
	// Bearer token to include in the authorization header
	Token *string `json:"token,omitempty"`
	// Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
	TokenAttributeName *string `json:"tokenAttributeName,omitempty"`
	// How often the OAuth token should be refreshed.
	TokenTimeoutSecs *int64 `json:"tokenTimeoutSecs,omitempty"`
	// Username for Basic authentication
	Username *string `json:"username,omitempty"`
}

func (o *Input111PrometheusAuth) GetAuthHeaderExpr() *string {
	if o == nil {
		return nil
	}
	return o.AuthHeaderExpr
}

func (o *Input111PrometheusAuth) GetAuthType() *Input111PrometheusAuthAuthenticationType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Input111PrometheusAuth) GetCredentialsSecret() *string {
	if o == nil {
		return nil
	}
	return o.CredentialsSecret
}

func (o *Input111PrometheusAuth) GetLoginURL() *string {
	if o == nil {
		return nil
	}
	return o.LoginURL
}

func (o *Input111PrometheusAuth) GetOauthHeaders() []Input111PrometheusAuthOauthHeaders {
	if o == nil {
		return nil
	}
	return o.OauthHeaders
}

func (o *Input111PrometheusAuth) GetOauthParams() []Input111PrometheusAuthOauthParams {
	if o == nil {
		return nil
	}
	return o.OauthParams
}

func (o *Input111PrometheusAuth) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *Input111PrometheusAuth) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

func (o *Input111PrometheusAuth) GetSecretParamName() *string {
	if o == nil {
		return nil
	}
	return o.SecretParamName
}

func (o *Input111PrometheusAuth) GetSpacer() *string {
	if o == nil {
		return nil
	}
	return o.Spacer
}

func (o *Input111PrometheusAuth) GetTextSecret() *string {
	if o == nil {
		return nil
	}
	return o.TextSecret
}

func (o *Input111PrometheusAuth) GetToken() *string {
	if o == nil {
		return nil
	}
	return o.Token
}

func (o *Input111PrometheusAuth) GetTokenAttributeName() *string {
	if o == nil {
		return nil
	}
	return o.TokenAttributeName
}

func (o *Input111PrometheusAuth) GetTokenTimeoutSecs() *int64 {
	if o == nil {
		return nil
	}
	return o.TokenTimeoutSecs
}

func (o *Input111PrometheusAuth) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

// Input111TLSSettingsServerSideMaximumTLSVersion - Maximum TLS version to accept from connections.
type Input111TLSSettingsServerSideMaximumTLSVersion string

const (
	Input111TLSSettingsServerSideMaximumTLSVersionTlSv1  Input111TLSSettingsServerSideMaximumTLSVersion = "TLSv1"
	Input111TLSSettingsServerSideMaximumTLSVersionTlSv11 Input111TLSSettingsServerSideMaximumTLSVersion = "TLSv1.1"
	Input111TLSSettingsServerSideMaximumTLSVersionTlSv12 Input111TLSSettingsServerSideMaximumTLSVersion = "TLSv1.2"
	Input111TLSSettingsServerSideMaximumTLSVersionTlSv13 Input111TLSSettingsServerSideMaximumTLSVersion = "TLSv1.3"
)

func (e Input111TLSSettingsServerSideMaximumTLSVersion) ToPointer() *Input111TLSSettingsServerSideMaximumTLSVersion {
	return &e
}

func (e *Input111TLSSettingsServerSideMaximumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = Input111TLSSettingsServerSideMaximumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input111TLSSettingsServerSideMaximumTLSVersion: %v", v)
	}
}

// Input111TLSSettingsServerSideMinimumTLSVersion - Minimum TLS version to accept from connections.
type Input111TLSSettingsServerSideMinimumTLSVersion string

const (
	Input111TLSSettingsServerSideMinimumTLSVersionTlSv1  Input111TLSSettingsServerSideMinimumTLSVersion = "TLSv1"
	Input111TLSSettingsServerSideMinimumTLSVersionTlSv11 Input111TLSSettingsServerSideMinimumTLSVersion = "TLSv1.1"
	Input111TLSSettingsServerSideMinimumTLSVersionTlSv12 Input111TLSSettingsServerSideMinimumTLSVersion = "TLSv1.2"
	Input111TLSSettingsServerSideMinimumTLSVersionTlSv13 Input111TLSSettingsServerSideMinimumTLSVersion = "TLSv1.3"
)

func (e Input111TLSSettingsServerSideMinimumTLSVersion) ToPointer() *Input111TLSSettingsServerSideMinimumTLSVersion {
	return &e
}

func (e *Input111TLSSettingsServerSideMinimumTLSVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TLSv1":
		fallthrough
	case "TLSv1.1":
		fallthrough
	case "TLSv1.2":
		fallthrough
	case "TLSv1.3":
		*e = Input111TLSSettingsServerSideMinimumTLSVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input111TLSSettingsServerSideMinimumTLSVersion: %v", v)
	}
}

type Input111TLSSettingsServerSide struct {
	// Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
	CaPath *string `json:"caPath,omitempty"`
	// Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
	CertPath *string `json:"certPath,omitempty"`
	// The name of the predefined certificate.
	CertificateName *string     `json:"certificateName,omitempty"`
	CommonNameRegex interface{} `json:"commonNameRegex,omitempty"`
	Disabled        *bool       `json:"disabled,omitempty"`
	// Maximum TLS version to accept from connections.
	MaxVersion *Input111TLSSettingsServerSideMaximumTLSVersion `json:"maxVersion,omitempty"`
	// Minimum TLS version to accept from connections.
	MinVersion *Input111TLSSettingsServerSideMinimumTLSVersion `json:"minVersion,omitempty"`
	// Passphrase to use to decrypt private key.
	Passphrase *string `json:"passphrase,omitempty"`
	// Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
	PrivKeyPath        *string     `json:"privKeyPath,omitempty"`
	RejectUnauthorized interface{} `json:"rejectUnauthorized,omitempty"`
	// Whether to require clients to present their certificates. Used to perform client authentication using SSL certs.
	RequestCert *bool `json:"requestCert,omitempty"`
}

func (o *Input111TLSSettingsServerSide) GetCaPath() *string {
	if o == nil {
		return nil
	}
	return o.CaPath
}

func (o *Input111TLSSettingsServerSide) GetCertPath() *string {
	if o == nil {
		return nil
	}
	return o.CertPath
}

func (o *Input111TLSSettingsServerSide) GetCertificateName() *string {
	if o == nil {
		return nil
	}
	return o.CertificateName
}

func (o *Input111TLSSettingsServerSide) GetCommonNameRegex() interface{} {
	if o == nil {
		return nil
	}
	return o.CommonNameRegex
}

func (o *Input111TLSSettingsServerSide) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *Input111TLSSettingsServerSide) GetMaxVersion() *Input111TLSSettingsServerSideMaximumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MaxVersion
}

func (o *Input111TLSSettingsServerSide) GetMinVersion() *Input111TLSSettingsServerSideMinimumTLSVersion {
	if o == nil {
		return nil
	}
	return o.MinVersion
}

func (o *Input111TLSSettingsServerSide) GetPassphrase() *string {
	if o == nil {
		return nil
	}
	return o.Passphrase
}

func (o *Input111TLSSettingsServerSide) GetPrivKeyPath() *string {
	if o == nil {
		return nil
	}
	return o.PrivKeyPath
}

func (o *Input111TLSSettingsServerSide) GetRejectUnauthorized() interface{} {
	if o == nil {
		return nil
	}
	return o.RejectUnauthorized
}

func (o *Input111TLSSettingsServerSide) GetRequestCert() *bool {
	if o == nil {
		return nil
	}
	return o.RequestCert
}

type Input111Type string

const (
	Input111TypeGrafana Input111Type = "grafana"
)

func (e Input111Type) ToPointer() *Input111Type {
	return &e
}

func (e *Input111Type) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "grafana":
		*e = Input111Type(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Input111Type: %v", v)
	}
}

type Input111 struct {
	// How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
	ActivityLogSampleRate *int64 `json:"activityLogSampleRate,omitempty"`
	// Toggle this to Yes to add request headers to events, in the __headers field.
	CaptureHeaders *bool `json:"captureHeaders,omitempty"`
	// Direct connections to Destinations, optionally via a Pipeline or a Pack.
	Connections []Input111Connections `json:"connections,omitempty"`
	// Enable/disable this input
	Disabled *bool `json:"disabled,omitempty"`
	// Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2.
	EnableProxyHeader *bool `json:"enableProxyHeader,omitempty"`
	// Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
	Environment *string `json:"environment,omitempty"`
	// Address to bind on. Defaults to 0.0.0.0 (all addresses).
	Host string `json:"host"`
	// Unique ID for this input
	ID *string `json:"id,omitempty"`
	// Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
	KeepAliveTimeout *int64 `json:"keepAliveTimeout,omitempty"`
	// Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'.
	LokiAPI  *string           `json:"lokiAPI,omitempty"`
	LokiAuth *Input111LokiAuth `json:"lokiAuth,omitempty"`
	// Maximum number of active requests per Worker Process. Use 0 for unlimited.
	MaxActiveReq *int64 `json:"maxActiveReq,omitempty"`
	// Fields to add to events from this input.
	Metadata []Input111Metadata `json:"metadata,omitempty"`
	// Pipeline to process data from this Source before sending it through the Routes.
	Pipeline *string `json:"pipeline,omitempty"`
	// Port to listen on.
	Port int64       `json:"port"`
	Pq   *Input111Pq `json:"pq,omitempty"`
	// For details on Persistent Queues, see: [https://docs.cribl.io/stream/persistent-queues](https://docs.cribl.io/stream/persistent-queues)
	PqEnabled *bool `json:"pqEnabled,omitempty"`
	// Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: http://<your‑upstream‑URL>:<your‑port>/api/prom/push.
	PrometheusAPI  string                  `json:"prometheusAPI"`
	PrometheusAuth *Input111PrometheusAuth `json:"prometheusAuth,omitempty"`
	// How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
	RequestTimeout *int64 `json:"requestTimeout,omitempty"`
	// Select whether to send data to Routes, or directly to Destinations.
	SendToRoutes *bool `json:"sendToRoutes,omitempty"`
	// How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
	SocketTimeout *int64 `json:"socketTimeout,omitempty"`
	// Add tags for filtering and grouping in @{product}.
	Streamtags []string                       `json:"streamtags,omitempty"`
	TLS        *Input111TLSSettingsServerSide `json:"tls,omitempty"`
	Type       *Input111Type                  `json:"type,omitempty"`
}

func (o *Input111) GetActivityLogSampleRate() *int64 {
	if o == nil {
		return nil
	}
	return o.ActivityLogSampleRate
}

func (o *Input111) GetCaptureHeaders() *bool {
	if o == nil {
		return nil
	}
	return o.CaptureHeaders
}

func (o *Input111) GetConnections() []Input111Connections {
	if o == nil {
		return nil
	}
	return o.Connections
}

func (o *Input111) GetDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.Disabled
}

func (o *Input111) GetEnableProxyHeader() *bool {
	if o == nil {
		return nil
	}
	return o.EnableProxyHeader
}

func (o *Input111) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *Input111) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *Input111) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Input111) GetKeepAliveTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.KeepAliveTimeout
}

func (o *Input111) GetLokiAPI() *string {
	if o == nil {
		return nil
	}
	return o.LokiAPI
}

func (o *Input111) GetLokiAuth() *Input111LokiAuth {
	if o == nil {
		return nil
	}
	return o.LokiAuth
}

func (o *Input111) GetMaxActiveReq() *int64 {
	if o == nil {
		return nil
	}
	return o.MaxActiveReq
}

func (o *Input111) GetMetadata() []Input111Metadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Input111) GetPipeline() *string {
	if o == nil {
		return nil
	}
	return o.Pipeline
}

func (o *Input111) GetPort() int64 {
	if o == nil {
		return 0
	}
	return o.Port
}

func (o *Input111) GetPq() *Input111Pq {
	if o == nil {
		return nil
	}
	return o.Pq
}

func (o *Input111) GetPqEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PqEnabled
}

func (o *Input111) GetPrometheusAPI() string {
	if o == nil {
		return ""
	}
	return o.PrometheusAPI
}

func (o *Input111) GetPrometheusAuth() *Input111PrometheusAuth {
	if o == nil {
		return nil
	}
	return o.PrometheusAuth
}

func (o *Input111) GetRequestTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.RequestTimeout
}

func (o *Input111) GetSendToRoutes() *bool {
	if o == nil {
		return nil
	}
	return o.SendToRoutes
}

func (o *Input111) GetSocketTimeout() *int64 {
	if o == nil {
		return nil
	}
	return o.SocketTimeout
}

func (o *Input111) GetStreamtags() []string {
	if o == nil {
		return nil
	}
	return o.Streamtags
}

func (o *Input111) GetTLS() *Input111TLSSettingsServerSide {
	if o == nil {
		return nil
	}
	return o.TLS
}

func (o *Input111) GetType() *Input111Type {
	if o == nil {
		return nil
	}
	return o.Type
}

// Inputs - a list of Input objects
type Inputs struct {
	// number of items present in the items array
	Count *int64        `json:"count,omitempty"`
	Items []interface{} `json:"items,omitempty"`
}

func (o *Inputs) GetCount() *int64 {
	if o == nil {
		return nil
	}
	return o.Count
}

func (o *Inputs) GetItems() []interface{} {
	if o == nil {
		return nil
	}
	return o.Items
}
